# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-02-11T14:30:54.859
# original file: /Users/nystrom/rai/nn-meta-13-pretty/proto/relationalai/lqp/v1/transactions.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ExportCSVColumn, Demand, Undefine, MaintenanceLevel, Define, Context, Sync, Abort
export Output, ExportCSVConfig, IVMConfig, Write, Export, Configure, Epoch, Read
export Transaction, WhatIf
abstract type var"##Abstract#Transaction" end
abstract type var"##Abstract#Epoch" end
abstract type var"##Abstract#Read" end
abstract type var"##Abstract#WhatIf" end


struct ExportCSVColumn
    column_name::String
    column_data::Union{Nothing,RelationId}
end
ExportCSVColumn(;column_name = "", column_data = nothing) = ExportCSVColumn(column_name, column_data)
PB.default_values(::Type{ExportCSVColumn}) = (;column_name = "", column_data = nothing)
PB.field_numbers(::Type{ExportCSVColumn}) = (;column_name = 1, column_data = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExportCSVColumn})
    column_name = ""
    column_data = Ref{Union{Nothing,RelationId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            column_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, column_data)
        else
            Base.skip(d, wire_type)
        end
    end
    return ExportCSVColumn(column_name, column_data[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExportCSVColumn)
    initpos = position(e.io)
    !isempty(x.column_name) && PB.encode(e, 1, x.column_name)
    !isnothing(x.column_data) && PB.encode(e, 2, x.column_data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExportCSVColumn)
    encoded_size = 0
    !isempty(x.column_name) && (encoded_size += PB._encoded_size(x.column_name, 1))
    !isnothing(x.column_data) && (encoded_size += PB._encoded_size(x.column_data, 2))
    return encoded_size
end

struct Demand
    relation_id::Union{Nothing,RelationId}
end
Demand(;relation_id = nothing) = Demand(relation_id)
PB.default_values(::Type{Demand}) = (;relation_id = nothing)
PB.field_numbers(::Type{Demand}) = (;relation_id = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Demand})
    relation_id = Ref{Union{Nothing,RelationId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, relation_id)
        else
            Base.skip(d, wire_type)
        end
    end
    return Demand(relation_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Demand)
    initpos = position(e.io)
    !isnothing(x.relation_id) && PB.encode(e, 1, x.relation_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Demand)
    encoded_size = 0
    !isnothing(x.relation_id) && (encoded_size += PB._encoded_size(x.relation_id, 1))
    return encoded_size
end

struct Undefine
    fragment_id::Union{Nothing,FragmentId}
end
Undefine(;fragment_id = nothing) = Undefine(fragment_id)
PB.default_values(::Type{Undefine}) = (;fragment_id = nothing)
PB.field_numbers(::Type{Undefine}) = (;fragment_id = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Undefine})
    fragment_id = Ref{Union{Nothing,FragmentId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, fragment_id)
        else
            Base.skip(d, wire_type)
        end
    end
    return Undefine(fragment_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Undefine)
    initpos = position(e.io)
    !isnothing(x.fragment_id) && PB.encode(e, 1, x.fragment_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Undefine)
    encoded_size = 0
    !isnothing(x.fragment_id) && (encoded_size += PB._encoded_size(x.fragment_id, 1))
    return encoded_size
end

@enumx MaintenanceLevel MAINTENANCE_LEVEL_UNSPECIFIED=0 MAINTENANCE_LEVEL_OFF=1 MAINTENANCE_LEVEL_AUTO=2 MAINTENANCE_LEVEL_ALL=3

struct Define
    fragment::Union{Nothing,Fragment}
end
Define(;fragment = nothing) = Define(fragment)
PB.default_values(::Type{Define}) = (;fragment = nothing)
PB.field_numbers(::Type{Define}) = (;fragment = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Define})
    fragment = Ref{Union{Nothing,Fragment}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, fragment)
        else
            Base.skip(d, wire_type)
        end
    end
    return Define(fragment[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Define)
    initpos = position(e.io)
    !isnothing(x.fragment) && PB.encode(e, 1, x.fragment)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Define)
    encoded_size = 0
    !isnothing(x.fragment) && (encoded_size += PB._encoded_size(x.fragment, 1))
    return encoded_size
end

struct Context
    relations::Vector{RelationId}
end
Context(;relations = Vector{RelationId}()) = Context(relations)
PB.default_values(::Type{Context}) = (;relations = Vector{RelationId}())
PB.field_numbers(::Type{Context}) = (;relations = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Context})
    relations = PB.BufferedVector{RelationId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, relations)
        else
            Base.skip(d, wire_type)
        end
    end
    return Context(relations[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Context)
    initpos = position(e.io)
    !isempty(x.relations) && PB.encode(e, 1, x.relations)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Context)
    encoded_size = 0
    !isempty(x.relations) && (encoded_size += PB._encoded_size(x.relations, 1))
    return encoded_size
end

struct Sync
    fragments::Vector{FragmentId}
end
Sync(;fragments = Vector{FragmentId}()) = Sync(fragments)
PB.default_values(::Type{Sync}) = (;fragments = Vector{FragmentId}())
PB.field_numbers(::Type{Sync}) = (;fragments = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Sync})
    fragments = PB.BufferedVector{FragmentId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, fragments)
        else
            Base.skip(d, wire_type)
        end
    end
    return Sync(fragments[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Sync)
    initpos = position(e.io)
    !isempty(x.fragments) && PB.encode(e, 1, x.fragments)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Sync)
    encoded_size = 0
    !isempty(x.fragments) && (encoded_size += PB._encoded_size(x.fragments, 1))
    return encoded_size
end

struct Abort
    name::String
    relation_id::Union{Nothing,RelationId}
end
Abort(;name = "", relation_id = nothing) = Abort(name, relation_id)
PB.default_values(::Type{Abort}) = (;name = "", relation_id = nothing)
PB.field_numbers(::Type{Abort}) = (;name = 1, relation_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Abort})
    name = ""
    relation_id = Ref{Union{Nothing,RelationId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, relation_id)
        else
            Base.skip(d, wire_type)
        end
    end
    return Abort(name, relation_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Abort)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.relation_id) && PB.encode(e, 2, x.relation_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Abort)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.relation_id) && (encoded_size += PB._encoded_size(x.relation_id, 2))
    return encoded_size
end

struct Output
    name::String
    relation_id::Union{Nothing,RelationId}
end
Output(;name = "", relation_id = nothing) = Output(name, relation_id)
PB.default_values(::Type{Output}) = (;name = "", relation_id = nothing)
PB.field_numbers(::Type{Output}) = (;name = 1, relation_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Output})
    name = ""
    relation_id = Ref{Union{Nothing,RelationId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, relation_id)
        else
            Base.skip(d, wire_type)
        end
    end
    return Output(name, relation_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Output)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.relation_id) && PB.encode(e, 2, x.relation_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Output)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.relation_id) && (encoded_size += PB._encoded_size(x.relation_id, 2))
    return encoded_size
end

struct ExportCSVConfig
    path::String
    data_columns::Vector{ExportCSVColumn}
    partition_size::Int64
    compression::String
    syntax_header_row::Bool
    syntax_missing_string::String
    syntax_delim::String
    syntax_quotechar::String
    syntax_escapechar::String
end
ExportCSVConfig(;path = "", data_columns = Vector{ExportCSVColumn}(), partition_size = zero(Int64), compression = "", syntax_header_row = false, syntax_missing_string = "", syntax_delim = "", syntax_quotechar = "", syntax_escapechar = "") = ExportCSVConfig(path, data_columns, partition_size, compression, syntax_header_row, syntax_missing_string, syntax_delim, syntax_quotechar, syntax_escapechar)
PB.default_values(::Type{ExportCSVConfig}) = (;path = "", data_columns = Vector{ExportCSVColumn}(), partition_size = zero(Int64), compression = "", syntax_header_row = false, syntax_missing_string = "", syntax_delim = "", syntax_quotechar = "", syntax_escapechar = "")
PB.field_numbers(::Type{ExportCSVConfig}) = (;path = 1, data_columns = 2, partition_size = 3, compression = 4, syntax_header_row = 5, syntax_missing_string = 6, syntax_delim = 7, syntax_quotechar = 8, syntax_escapechar = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExportCSVConfig})
    path = ""
    data_columns = PB.BufferedVector{ExportCSVColumn}()
    partition_size = zero(Int64)
    compression = ""
    syntax_header_row = false
    syntax_missing_string = ""
    syntax_delim = ""
    syntax_quotechar = ""
    syntax_escapechar = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            path = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, data_columns)
        elseif field_number == 3
            partition_size = PB.decode(d, Int64)
        elseif field_number == 4
            compression = PB.decode(d, String)
        elseif field_number == 5
            syntax_header_row = PB.decode(d, Bool)
        elseif field_number == 6
            syntax_missing_string = PB.decode(d, String)
        elseif field_number == 7
            syntax_delim = PB.decode(d, String)
        elseif field_number == 8
            syntax_quotechar = PB.decode(d, String)
        elseif field_number == 9
            syntax_escapechar = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return ExportCSVConfig(path, data_columns[], partition_size, compression, syntax_header_row, syntax_missing_string, syntax_delim, syntax_quotechar, syntax_escapechar)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExportCSVConfig)
    initpos = position(e.io)
    !isempty(x.path) && PB.encode(e, 1, x.path)
    !isempty(x.data_columns) && PB.encode(e, 2, x.data_columns)
    x.partition_size != zero(Int64) && PB.encode(e, 3, x.partition_size)
    !isempty(x.compression) && PB.encode(e, 4, x.compression)
    x.syntax_header_row != false && PB.encode(e, 5, x.syntax_header_row)
    !isempty(x.syntax_missing_string) && PB.encode(e, 6, x.syntax_missing_string)
    !isempty(x.syntax_delim) && PB.encode(e, 7, x.syntax_delim)
    !isempty(x.syntax_quotechar) && PB.encode(e, 8, x.syntax_quotechar)
    !isempty(x.syntax_escapechar) && PB.encode(e, 9, x.syntax_escapechar)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExportCSVConfig)
    encoded_size = 0
    !isempty(x.path) && (encoded_size += PB._encoded_size(x.path, 1))
    !isempty(x.data_columns) && (encoded_size += PB._encoded_size(x.data_columns, 2))
    x.partition_size != zero(Int64) && (encoded_size += PB._encoded_size(x.partition_size, 3))
    !isempty(x.compression) && (encoded_size += PB._encoded_size(x.compression, 4))
    x.syntax_header_row != false && (encoded_size += PB._encoded_size(x.syntax_header_row, 5))
    !isempty(x.syntax_missing_string) && (encoded_size += PB._encoded_size(x.syntax_missing_string, 6))
    !isempty(x.syntax_delim) && (encoded_size += PB._encoded_size(x.syntax_delim, 7))
    !isempty(x.syntax_quotechar) && (encoded_size += PB._encoded_size(x.syntax_quotechar, 8))
    !isempty(x.syntax_escapechar) && (encoded_size += PB._encoded_size(x.syntax_escapechar, 9))
    return encoded_size
end

struct IVMConfig
    level::MaintenanceLevel.T
end
IVMConfig(;level = MaintenanceLevel.MAINTENANCE_LEVEL_UNSPECIFIED) = IVMConfig(level)
PB.default_values(::Type{IVMConfig}) = (;level = MaintenanceLevel.MAINTENANCE_LEVEL_UNSPECIFIED)
PB.field_numbers(::Type{IVMConfig}) = (;level = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IVMConfig})
    level = MaintenanceLevel.MAINTENANCE_LEVEL_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            level = PB.decode(d, MaintenanceLevel.T)
        else
            Base.skip(d, wire_type)
        end
    end
    return IVMConfig(level)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IVMConfig)
    initpos = position(e.io)
    x.level != MaintenanceLevel.MAINTENANCE_LEVEL_UNSPECIFIED && PB.encode(e, 1, x.level)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IVMConfig)
    encoded_size = 0
    x.level != MaintenanceLevel.MAINTENANCE_LEVEL_UNSPECIFIED && (encoded_size += PB._encoded_size(x.level, 1))
    return encoded_size
end

struct Write
    write_type::Union{Nothing,OneOf{<:Union{Define,Undefine,Context}}}
end
Write(;write_type = nothing) = Write(write_type)
PB.reserved_fields(::Type{Write}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.oneof_field_types(::Type{Write}) = (;
    write_type = (;define=Define, undefine=Undefine, context=Context),
)
PB.default_values(::Type{Write}) = (;define = nothing, undefine = nothing, context = nothing)
PB.field_numbers(::Type{Write}) = (;define = 1, undefine = 2, context = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Write})
    write_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            write_type = OneOf(:define, PB.decode(d, Ref{Define}))
        elseif field_number == 2
            write_type = OneOf(:undefine, PB.decode(d, Ref{Undefine}))
        elseif field_number == 3
            write_type = OneOf(:context, PB.decode(d, Ref{Context}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Write(write_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Write)
    initpos = position(e.io)
    if isnothing(x.write_type);
    elseif x.write_type.name === :define
        PB.encode(e, 1, x.write_type[]::Define)
    elseif x.write_type.name === :undefine
        PB.encode(e, 2, x.write_type[]::Undefine)
    elseif x.write_type.name === :context
        PB.encode(e, 3, x.write_type[]::Context)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Write)
    encoded_size = 0
    if isnothing(x.write_type);
    elseif x.write_type.name === :define
        encoded_size += PB._encoded_size(x.write_type[]::Define, 1)
    elseif x.write_type.name === :undefine
        encoded_size += PB._encoded_size(x.write_type[]::Undefine, 2)
    elseif x.write_type.name === :context
        encoded_size += PB._encoded_size(x.write_type[]::Context, 3)
    end
    return encoded_size
end

struct Export
    export_config::Union{Nothing,OneOf{ExportCSVConfig}}
end
Export(;export_config = nothing) = Export(export_config)
PB.oneof_field_types(::Type{Export}) = (;
    export_config = (;csv_config=ExportCSVConfig),
)
PB.default_values(::Type{Export}) = (;csv_config = nothing)
PB.field_numbers(::Type{Export}) = (;csv_config = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Export})
    export_config = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            export_config = OneOf(:csv_config, PB.decode(d, Ref{ExportCSVConfig}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Export(export_config)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Export)
    initpos = position(e.io)
    if isnothing(x.export_config);
    elseif x.export_config.name === :csv_config
        PB.encode(e, 1, x.export_config[]::ExportCSVConfig)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Export)
    encoded_size = 0
    if isnothing(x.export_config);
    elseif x.export_config.name === :csv_config
        encoded_size += PB._encoded_size(x.export_config[]::ExportCSVConfig, 1)
    end
    return encoded_size
end

struct Configure
    semantics_version::Int64
    ivm_config::Union{Nothing,IVMConfig}
end
Configure(;semantics_version = zero(Int64), ivm_config = nothing) = Configure(semantics_version, ivm_config)
PB.default_values(::Type{Configure}) = (;semantics_version = zero(Int64), ivm_config = nothing)
PB.field_numbers(::Type{Configure}) = (;semantics_version = 1, ivm_config = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Configure})
    semantics_version = zero(Int64)
    ivm_config = Ref{Union{Nothing,IVMConfig}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            semantics_version = PB.decode(d, Int64)
        elseif field_number == 2
            PB.decode!(d, ivm_config)
        else
            Base.skip(d, wire_type)
        end
    end
    return Configure(semantics_version, ivm_config[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Configure)
    initpos = position(e.io)
    x.semantics_version != zero(Int64) && PB.encode(e, 1, x.semantics_version)
    !isnothing(x.ivm_config) && PB.encode(e, 2, x.ivm_config)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Configure)
    encoded_size = 0
    x.semantics_version != zero(Int64) && (encoded_size += PB._encoded_size(x.semantics_version, 1))
    !isnothing(x.ivm_config) && (encoded_size += PB._encoded_size(x.ivm_config, 2))
    return encoded_size
end

# Stub definitions for cyclic types
struct var"##Stub#Epoch"{T1<:var"##Abstract#Read"} <: var"##Abstract#Epoch"
    writes::Vector{Write}
    reads::Vector{T1}
end

struct var"##Stub#Read"{T1<:var"##Abstract#WhatIf"} <: var"##Abstract#Read"
    read_type::Union{Nothing,OneOf{<:Union{Demand,Output,T1,Abort,Export}}}
end

struct var"##Stub#Transaction"{T1<:var"##Abstract#WhatIf"} <: var"##Abstract#Transaction"
    epochs::Vector{var"##Stub#Epoch"{var"##Stub#Read"{T1}}}
    configure::Union{Nothing,Configure}
    sync::Union{Nothing,Sync}
end

struct var"##Stub#WhatIf" <: var"##Abstract#WhatIf"
    branch::String
    epoch::Union{Nothing,var"##Stub#Epoch"{var"##Stub#Read"{var"##Stub#WhatIf"}}}
end

const Epoch = var"##Stub#Epoch"{var"##Stub#Read"{var"##Stub#WhatIf"}}
Epoch(;writes = Vector{Write}(), reads = Vector{Read}()) = Epoch(writes, reads)
PB.default_values(::Type{Epoch}) = (;writes = Vector{Write}(), reads = Vector{Read}())
PB.field_numbers(::Type{Epoch}) = (;writes = 1, reads = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Epoch})
    writes = PB.BufferedVector{Write}()
    reads = PB.BufferedVector{Read}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, writes)
        elseif field_number == 2
            PB.decode!(d, reads)
        else
            Base.skip(d, wire_type)
        end
    end
    return Epoch(writes[], reads[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Epoch)
    initpos = position(e.io)
    !isempty(x.writes) && PB.encode(e, 1, x.writes)
    !isempty(x.reads) && PB.encode(e, 2, x.reads)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Epoch)
    encoded_size = 0
    !isempty(x.writes) && (encoded_size += PB._encoded_size(x.writes, 1))
    !isempty(x.reads) && (encoded_size += PB._encoded_size(x.reads, 2))
    return encoded_size
end

const Read = var"##Stub#Read"{var"##Stub#WhatIf"}
Read(;read_type = nothing) = Read(read_type)
PB.oneof_field_types(::Type{Read}) = (;
    read_type = (;demand=Demand, output=Output, what_if=WhatIf, abort=Abort, var"#export"=Export),
)
PB.default_values(::Type{Read}) = (;demand = nothing, output = nothing, what_if = nothing, abort = nothing, var"#export" = nothing)
PB.field_numbers(::Type{Read}) = (;demand = 1, output = 2, what_if = 3, abort = 4, var"#export" = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Read})
    read_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            read_type = OneOf(:demand, PB.decode(d, Ref{Demand}))
        elseif field_number == 2
            read_type = OneOf(:output, PB.decode(d, Ref{Output}))
        elseif field_number == 3
            read_type = OneOf(:what_if, PB.decode(d, Ref{WhatIf}))
        elseif field_number == 4
            read_type = OneOf(:abort, PB.decode(d, Ref{Abort}))
        elseif field_number == 5
            read_type = OneOf(:var"#export", PB.decode(d, Ref{Export}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Read(read_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Read)
    initpos = position(e.io)
    if isnothing(x.read_type);
    elseif x.read_type.name === :demand
        PB.encode(e, 1, x.read_type[]::Demand)
    elseif x.read_type.name === :output
        PB.encode(e, 2, x.read_type[]::Output)
    elseif x.read_type.name === :what_if
        PB.encode(e, 3, x.read_type[]::WhatIf)
    elseif x.read_type.name === :abort
        PB.encode(e, 4, x.read_type[]::Abort)
    elseif x.read_type.name === :var"#export"
        PB.encode(e, 5, x.read_type[]::Export)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Read)
    encoded_size = 0
    if isnothing(x.read_type);
    elseif x.read_type.name === :demand
        encoded_size += PB._encoded_size(x.read_type[]::Demand, 1)
    elseif x.read_type.name === :output
        encoded_size += PB._encoded_size(x.read_type[]::Output, 2)
    elseif x.read_type.name === :what_if
        encoded_size += PB._encoded_size(x.read_type[]::WhatIf, 3)
    elseif x.read_type.name === :abort
        encoded_size += PB._encoded_size(x.read_type[]::Abort, 4)
    elseif x.read_type.name === :var"#export"
        encoded_size += PB._encoded_size(x.read_type[]::Export, 5)
    end
    return encoded_size
end

const Transaction = var"##Stub#Transaction"{var"##Stub#WhatIf"}
Transaction(;epochs = Vector{Epoch}(), configure = nothing, sync = nothing) = Transaction(epochs, configure, sync)
PB.default_values(::Type{Transaction}) = (;epochs = Vector{Epoch}(), configure = nothing, sync = nothing)
PB.field_numbers(::Type{Transaction}) = (;epochs = 1, configure = 2, sync = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Transaction})
    epochs = PB.BufferedVector{Epoch}()
    configure = Ref{Union{Nothing,Configure}}(nothing)
    sync = Ref{Union{Nothing,Sync}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, epochs)
        elseif field_number == 2
            PB.decode!(d, configure)
        elseif field_number == 3
            PB.decode!(d, sync)
        else
            Base.skip(d, wire_type)
        end
    end
    return Transaction(epochs[], configure[], sync[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Transaction)
    initpos = position(e.io)
    !isempty(x.epochs) && PB.encode(e, 1, x.epochs)
    !isnothing(x.configure) && PB.encode(e, 2, x.configure)
    !isnothing(x.sync) && PB.encode(e, 3, x.sync)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Transaction)
    encoded_size = 0
    !isempty(x.epochs) && (encoded_size += PB._encoded_size(x.epochs, 1))
    !isnothing(x.configure) && (encoded_size += PB._encoded_size(x.configure, 2))
    !isnothing(x.sync) && (encoded_size += PB._encoded_size(x.sync, 3))
    return encoded_size
end

const WhatIf = var"##Stub#WhatIf"
WhatIf(;branch = "", epoch = nothing) = WhatIf(branch, epoch)
PB.default_values(::Type{WhatIf}) = (;branch = "", epoch = nothing)
PB.field_numbers(::Type{WhatIf}) = (;branch = 1, epoch = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:WhatIf})
    branch = ""
    epoch = Ref{Union{Nothing,Epoch}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            branch = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, epoch)
        else
            Base.skip(d, wire_type)
        end
    end
    return WhatIf(branch, epoch[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::WhatIf)
    initpos = position(e.io)
    !isempty(x.branch) && PB.encode(e, 1, x.branch)
    !isnothing(x.epoch) && PB.encode(e, 2, x.epoch)
    return position(e.io) - initpos
end
function PB._encoded_size(x::WhatIf)
    encoded_size = 0
    !isempty(x.branch) && (encoded_size += PB._encoded_size(x.branch, 1))
    !isnothing(x.epoch) && (encoded_size += PB._encoded_size(x.epoch, 2))
    return encoded_size
end
