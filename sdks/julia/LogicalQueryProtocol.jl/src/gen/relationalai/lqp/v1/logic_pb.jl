# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-02-23T07:41:45.814
# original file: /Users/dzhao/Documents/logical-query-protocol/proto/relationalai/lqp/v1/logic.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export DateTimeType, RelationId, Var, FloatType, UInt128Type, BeTreeConfig, DateTimeValue
export DateValue, OrMonoid, CSVLocator, Int128Type, DecimalType, UnspecifiedType, DateType
export MissingType, MissingValue, CSVConfig, IntType, StringType, Int128Value, UInt128Value
export BooleanType, DecimalValue, BeTreeLocator, var"#Type", Value, RelEDB, MinMonoid
export SumMonoid, MaxMonoid, BeTreeInfo, Binding, CSVColumn, Attribute, Term, Monoid
export BeTreeRelation, CSVData, Cast, Pragma, Atom, RelTerm, Data, Primitive, RelAtom
export Abstraction, Algorithm, Assign, Break, Conjunction, Constraint, Def, Disjunction
export Exists, FFI, FunctionalDependency, MonoidDef, MonusDef, Not, Reduce, Script, Upsert
export Construct, Loop, Declaration, Instruction, Formula
abstract type var"##Abstract#Abstraction" end
abstract type var"##Abstract#Not" end
abstract type var"##Abstract#Break" end
abstract type var"##Abstract#Reduce" end
abstract type var"##Abstract#Exists" end
abstract type var"##Abstract#FFI" end
abstract type var"##Abstract#Formula" end
abstract type var"##Abstract#Conjunction" end
abstract type var"##Abstract#Disjunction" end
abstract type var"##Abstract#Algorithm" end
abstract type var"##Abstract#MonoidDef" end
abstract type var"##Abstract#Loop" end
abstract type var"##Abstract#Def" end
abstract type var"##Abstract#Construct" end
abstract type var"##Abstract#Constraint" end
abstract type var"##Abstract#FunctionalDependency" end
abstract type var"##Abstract#MonusDef" end
abstract type var"##Abstract#Script" end
abstract type var"##Abstract#Declaration" end
abstract type var"##Abstract#Instruction" end
abstract type var"##Abstract#Assign" end
abstract type var"##Abstract#Upsert" end


struct DateTimeType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DateTimeType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return DateTimeType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DateTimeType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DateTimeType)
    encoded_size = 0
    return encoded_size
end

struct RelationId
    id_low::UInt64
    id_high::UInt64
end
RelationId(;id_low = zero(UInt64), id_high = zero(UInt64)) = RelationId(id_low, id_high)
PB.default_values(::Type{RelationId}) = (;id_low = zero(UInt64), id_high = zero(UInt64))
PB.field_numbers(::Type{RelationId}) = (;id_low = 1, id_high = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelationId})
    id_low = zero(UInt64)
    id_high = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id_low = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 2
            id_high = PB.decode(d, UInt64, Val{:fixed})
        else
            Base.skip(d, wire_type)
        end
    end
    return RelationId(id_low, id_high)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelationId)
    initpos = position(e.io)
    x.id_low != zero(UInt64) && PB.encode(e, 1, x.id_low, Val{:fixed})
    x.id_high != zero(UInt64) && PB.encode(e, 2, x.id_high, Val{:fixed})
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelationId)
    encoded_size = 0
    x.id_low != zero(UInt64) && (encoded_size += PB._encoded_size(x.id_low, 1, Val{:fixed}))
    x.id_high != zero(UInt64) && (encoded_size += PB._encoded_size(x.id_high, 2, Val{:fixed}))
    return encoded_size
end

struct Var
    name::String
end
Var(;name = "") = Var(name)
PB.default_values(::Type{Var}) = (;name = "")
PB.field_numbers(::Type{Var}) = (;name = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Var})
    name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return Var(name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Var)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Var)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    return encoded_size
end

struct FloatType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FloatType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return FloatType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FloatType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FloatType)
    encoded_size = 0
    return encoded_size
end

struct UInt128Type end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UInt128Type})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return UInt128Type()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UInt128Type)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::UInt128Type)
    encoded_size = 0
    return encoded_size
end

struct BeTreeConfig
    epsilon::Float64
    max_pivots::Int64
    max_deltas::Int64
    max_leaf::Int64
end
BeTreeConfig(;epsilon = zero(Float64), max_pivots = zero(Int64), max_deltas = zero(Int64), max_leaf = zero(Int64)) = BeTreeConfig(epsilon, max_pivots, max_deltas, max_leaf)
PB.default_values(::Type{BeTreeConfig}) = (;epsilon = zero(Float64), max_pivots = zero(Int64), max_deltas = zero(Int64), max_leaf = zero(Int64))
PB.field_numbers(::Type{BeTreeConfig}) = (;epsilon = 1, max_pivots = 2, max_deltas = 3, max_leaf = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BeTreeConfig})
    epsilon = zero(Float64)
    max_pivots = zero(Int64)
    max_deltas = zero(Int64)
    max_leaf = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            epsilon = PB.decode(d, Float64)
        elseif field_number == 2
            max_pivots = PB.decode(d, Int64)
        elseif field_number == 3
            max_deltas = PB.decode(d, Int64)
        elseif field_number == 4
            max_leaf = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return BeTreeConfig(epsilon, max_pivots, max_deltas, max_leaf)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BeTreeConfig)
    initpos = position(e.io)
    x.epsilon !== zero(Float64) && PB.encode(e, 1, x.epsilon)
    x.max_pivots != zero(Int64) && PB.encode(e, 2, x.max_pivots)
    x.max_deltas != zero(Int64) && PB.encode(e, 3, x.max_deltas)
    x.max_leaf != zero(Int64) && PB.encode(e, 4, x.max_leaf)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BeTreeConfig)
    encoded_size = 0
    x.epsilon !== zero(Float64) && (encoded_size += PB._encoded_size(x.epsilon, 1))
    x.max_pivots != zero(Int64) && (encoded_size += PB._encoded_size(x.max_pivots, 2))
    x.max_deltas != zero(Int64) && (encoded_size += PB._encoded_size(x.max_deltas, 3))
    x.max_leaf != zero(Int64) && (encoded_size += PB._encoded_size(x.max_leaf, 4))
    return encoded_size
end

struct DateTimeValue
    year::Int32
    month::Int32
    day::Int32
    hour::Int32
    minute::Int32
    second::Int32
    microsecond::Int32
end
DateTimeValue(;year = zero(Int32), month = zero(Int32), day = zero(Int32), hour = zero(Int32), minute = zero(Int32), second = zero(Int32), microsecond = zero(Int32)) = DateTimeValue(year, month, day, hour, minute, second, microsecond)
PB.default_values(::Type{DateTimeValue}) = (;year = zero(Int32), month = zero(Int32), day = zero(Int32), hour = zero(Int32), minute = zero(Int32), second = zero(Int32), microsecond = zero(Int32))
PB.field_numbers(::Type{DateTimeValue}) = (;year = 1, month = 2, day = 3, hour = 4, minute = 5, second = 6, microsecond = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DateTimeValue})
    year = zero(Int32)
    month = zero(Int32)
    day = zero(Int32)
    hour = zero(Int32)
    minute = zero(Int32)
    second = zero(Int32)
    microsecond = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            year = PB.decode(d, Int32)
        elseif field_number == 2
            month = PB.decode(d, Int32)
        elseif field_number == 3
            day = PB.decode(d, Int32)
        elseif field_number == 4
            hour = PB.decode(d, Int32)
        elseif field_number == 5
            minute = PB.decode(d, Int32)
        elseif field_number == 6
            second = PB.decode(d, Int32)
        elseif field_number == 7
            microsecond = PB.decode(d, Int32)
        else
            Base.skip(d, wire_type)
        end
    end
    return DateTimeValue(year, month, day, hour, minute, second, microsecond)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DateTimeValue)
    initpos = position(e.io)
    x.year != zero(Int32) && PB.encode(e, 1, x.year)
    x.month != zero(Int32) && PB.encode(e, 2, x.month)
    x.day != zero(Int32) && PB.encode(e, 3, x.day)
    x.hour != zero(Int32) && PB.encode(e, 4, x.hour)
    x.minute != zero(Int32) && PB.encode(e, 5, x.minute)
    x.second != zero(Int32) && PB.encode(e, 6, x.second)
    x.microsecond != zero(Int32) && PB.encode(e, 7, x.microsecond)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DateTimeValue)
    encoded_size = 0
    x.year != zero(Int32) && (encoded_size += PB._encoded_size(x.year, 1))
    x.month != zero(Int32) && (encoded_size += PB._encoded_size(x.month, 2))
    x.day != zero(Int32) && (encoded_size += PB._encoded_size(x.day, 3))
    x.hour != zero(Int32) && (encoded_size += PB._encoded_size(x.hour, 4))
    x.minute != zero(Int32) && (encoded_size += PB._encoded_size(x.minute, 5))
    x.second != zero(Int32) && (encoded_size += PB._encoded_size(x.second, 6))
    x.microsecond != zero(Int32) && (encoded_size += PB._encoded_size(x.microsecond, 7))
    return encoded_size
end

struct DateValue
    year::Int32
    month::Int32
    day::Int32
end
DateValue(;year = zero(Int32), month = zero(Int32), day = zero(Int32)) = DateValue(year, month, day)
PB.default_values(::Type{DateValue}) = (;year = zero(Int32), month = zero(Int32), day = zero(Int32))
PB.field_numbers(::Type{DateValue}) = (;year = 1, month = 2, day = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DateValue})
    year = zero(Int32)
    month = zero(Int32)
    day = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            year = PB.decode(d, Int32)
        elseif field_number == 2
            month = PB.decode(d, Int32)
        elseif field_number == 3
            day = PB.decode(d, Int32)
        else
            Base.skip(d, wire_type)
        end
    end
    return DateValue(year, month, day)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DateValue)
    initpos = position(e.io)
    x.year != zero(Int32) && PB.encode(e, 1, x.year)
    x.month != zero(Int32) && PB.encode(e, 2, x.month)
    x.day != zero(Int32) && PB.encode(e, 3, x.day)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DateValue)
    encoded_size = 0
    x.year != zero(Int32) && (encoded_size += PB._encoded_size(x.year, 1))
    x.month != zero(Int32) && (encoded_size += PB._encoded_size(x.month, 2))
    x.day != zero(Int32) && (encoded_size += PB._encoded_size(x.day, 3))
    return encoded_size
end

struct OrMonoid end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OrMonoid})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return OrMonoid()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OrMonoid)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OrMonoid)
    encoded_size = 0
    return encoded_size
end

struct CSVLocator
    paths::Vector{String}
    inline_data::Vector{UInt8}
end
CSVLocator(;paths = Vector{String}(), inline_data = UInt8[]) = CSVLocator(paths, inline_data)
PB.default_values(::Type{CSVLocator}) = (;paths = Vector{String}(), inline_data = UInt8[])
PB.field_numbers(::Type{CSVLocator}) = (;paths = 1, inline_data = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CSVLocator})
    paths = PB.BufferedVector{String}()
    inline_data = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, paths)
        elseif field_number == 2
            inline_data = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return CSVLocator(paths[], inline_data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CSVLocator)
    initpos = position(e.io)
    !isempty(x.paths) && PB.encode(e, 1, x.paths)
    !isempty(x.inline_data) && PB.encode(e, 2, x.inline_data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CSVLocator)
    encoded_size = 0
    !isempty(x.paths) && (encoded_size += PB._encoded_size(x.paths, 1))
    !isempty(x.inline_data) && (encoded_size += PB._encoded_size(x.inline_data, 2))
    return encoded_size
end

struct Int128Type end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Int128Type})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return Int128Type()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Int128Type)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Int128Type)
    encoded_size = 0
    return encoded_size
end

struct DecimalType
    precision::Int32
    scale::Int32
end
DecimalType(;precision = zero(Int32), scale = zero(Int32)) = DecimalType(precision, scale)
PB.default_values(::Type{DecimalType}) = (;precision = zero(Int32), scale = zero(Int32))
PB.field_numbers(::Type{DecimalType}) = (;precision = 1, scale = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DecimalType})
    precision = zero(Int32)
    scale = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            precision = PB.decode(d, Int32)
        elseif field_number == 2
            scale = PB.decode(d, Int32)
        else
            Base.skip(d, wire_type)
        end
    end
    return DecimalType(precision, scale)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DecimalType)
    initpos = position(e.io)
    x.precision != zero(Int32) && PB.encode(e, 1, x.precision)
    x.scale != zero(Int32) && PB.encode(e, 2, x.scale)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DecimalType)
    encoded_size = 0
    x.precision != zero(Int32) && (encoded_size += PB._encoded_size(x.precision, 1))
    x.scale != zero(Int32) && (encoded_size += PB._encoded_size(x.scale, 2))
    return encoded_size
end

struct UnspecifiedType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UnspecifiedType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return UnspecifiedType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UnspecifiedType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::UnspecifiedType)
    encoded_size = 0
    return encoded_size
end

struct DateType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DateType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return DateType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DateType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DateType)
    encoded_size = 0
    return encoded_size
end

struct MissingType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MissingType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return MissingType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MissingType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MissingType)
    encoded_size = 0
    return encoded_size
end

struct MissingValue end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MissingValue})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return MissingValue()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MissingValue)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MissingValue)
    encoded_size = 0
    return encoded_size
end

struct CSVConfig
    header_row::Int32
    skip::Int64
    new_line::String
    delimiter::String
    quotechar::String
    escapechar::String
    comment::String
    missing_strings::Vector{String}
    decimal_separator::String
    encoding::String
    compression::String
    partition_size_mb::Int64
end
CSVConfig(;header_row = zero(Int32), skip = zero(Int64), new_line = "", delimiter = "", quotechar = "", escapechar = "", comment = "", missing_strings = Vector{String}(), decimal_separator = "", encoding = "", compression = "", partition_size_mb = zero(Int64)) = CSVConfig(header_row, skip, new_line, delimiter, quotechar, escapechar, comment, missing_strings, decimal_separator, encoding, compression, partition_size_mb)
PB.default_values(::Type{CSVConfig}) = (;header_row = zero(Int32), skip = zero(Int64), new_line = "", delimiter = "", quotechar = "", escapechar = "", comment = "", missing_strings = Vector{String}(), decimal_separator = "", encoding = "", compression = "", partition_size_mb = zero(Int64))
PB.field_numbers(::Type{CSVConfig}) = (;header_row = 1, skip = 2, new_line = 3, delimiter = 4, quotechar = 5, escapechar = 6, comment = 7, missing_strings = 8, decimal_separator = 9, encoding = 10, compression = 11, partition_size_mb = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CSVConfig})
    header_row = zero(Int32)
    skip = zero(Int64)
    new_line = ""
    delimiter = ""
    quotechar = ""
    escapechar = ""
    comment = ""
    missing_strings = PB.BufferedVector{String}()
    decimal_separator = ""
    encoding = ""
    compression = ""
    partition_size_mb = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            header_row = PB.decode(d, Int32)
        elseif field_number == 2
            skip = PB.decode(d, Int64)
        elseif field_number == 3
            new_line = PB.decode(d, String)
        elseif field_number == 4
            delimiter = PB.decode(d, String)
        elseif field_number == 5
            quotechar = PB.decode(d, String)
        elseif field_number == 6
            escapechar = PB.decode(d, String)
        elseif field_number == 7
            comment = PB.decode(d, String)
        elseif field_number == 8
            PB.decode!(d, missing_strings)
        elseif field_number == 9
            decimal_separator = PB.decode(d, String)
        elseif field_number == 10
            encoding = PB.decode(d, String)
        elseif field_number == 11
            compression = PB.decode(d, String)
        elseif field_number == 12
            partition_size_mb = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return CSVConfig(header_row, skip, new_line, delimiter, quotechar, escapechar, comment, missing_strings[], decimal_separator, encoding, compression, partition_size_mb)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CSVConfig)
    initpos = position(e.io)
    x.header_row != zero(Int32) && PB.encode(e, 1, x.header_row)
    x.skip != zero(Int64) && PB.encode(e, 2, x.skip)
    !isempty(x.new_line) && PB.encode(e, 3, x.new_line)
    !isempty(x.delimiter) && PB.encode(e, 4, x.delimiter)
    !isempty(x.quotechar) && PB.encode(e, 5, x.quotechar)
    !isempty(x.escapechar) && PB.encode(e, 6, x.escapechar)
    !isempty(x.comment) && PB.encode(e, 7, x.comment)
    !isempty(x.missing_strings) && PB.encode(e, 8, x.missing_strings)
    !isempty(x.decimal_separator) && PB.encode(e, 9, x.decimal_separator)
    !isempty(x.encoding) && PB.encode(e, 10, x.encoding)
    !isempty(x.compression) && PB.encode(e, 11, x.compression)
    x.partition_size_mb != zero(Int64) && PB.encode(e, 12, x.partition_size_mb)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CSVConfig)
    encoded_size = 0
    x.header_row != zero(Int32) && (encoded_size += PB._encoded_size(x.header_row, 1))
    x.skip != zero(Int64) && (encoded_size += PB._encoded_size(x.skip, 2))
    !isempty(x.new_line) && (encoded_size += PB._encoded_size(x.new_line, 3))
    !isempty(x.delimiter) && (encoded_size += PB._encoded_size(x.delimiter, 4))
    !isempty(x.quotechar) && (encoded_size += PB._encoded_size(x.quotechar, 5))
    !isempty(x.escapechar) && (encoded_size += PB._encoded_size(x.escapechar, 6))
    !isempty(x.comment) && (encoded_size += PB._encoded_size(x.comment, 7))
    !isempty(x.missing_strings) && (encoded_size += PB._encoded_size(x.missing_strings, 8))
    !isempty(x.decimal_separator) && (encoded_size += PB._encoded_size(x.decimal_separator, 9))
    !isempty(x.encoding) && (encoded_size += PB._encoded_size(x.encoding, 10))
    !isempty(x.compression) && (encoded_size += PB._encoded_size(x.compression, 11))
    x.partition_size_mb != zero(Int64) && (encoded_size += PB._encoded_size(x.partition_size_mb, 12))
    return encoded_size
end

struct IntType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IntType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return IntType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IntType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IntType)
    encoded_size = 0
    return encoded_size
end

struct StringType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StringType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return StringType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StringType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StringType)
    encoded_size = 0
    return encoded_size
end

struct Int128Value
    low::UInt64
    high::UInt64
end
Int128Value(;low = zero(UInt64), high = zero(UInt64)) = Int128Value(low, high)
PB.default_values(::Type{Int128Value}) = (;low = zero(UInt64), high = zero(UInt64))
PB.field_numbers(::Type{Int128Value}) = (;low = 1, high = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Int128Value})
    low = zero(UInt64)
    high = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            low = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 2
            high = PB.decode(d, UInt64, Val{:fixed})
        else
            Base.skip(d, wire_type)
        end
    end
    return Int128Value(low, high)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Int128Value)
    initpos = position(e.io)
    x.low != zero(UInt64) && PB.encode(e, 1, x.low, Val{:fixed})
    x.high != zero(UInt64) && PB.encode(e, 2, x.high, Val{:fixed})
    return position(e.io) - initpos
end
function PB._encoded_size(x::Int128Value)
    encoded_size = 0
    x.low != zero(UInt64) && (encoded_size += PB._encoded_size(x.low, 1, Val{:fixed}))
    x.high != zero(UInt64) && (encoded_size += PB._encoded_size(x.high, 2, Val{:fixed}))
    return encoded_size
end

struct UInt128Value
    low::UInt64
    high::UInt64
end
UInt128Value(;low = zero(UInt64), high = zero(UInt64)) = UInt128Value(low, high)
PB.default_values(::Type{UInt128Value}) = (;low = zero(UInt64), high = zero(UInt64))
PB.field_numbers(::Type{UInt128Value}) = (;low = 1, high = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UInt128Value})
    low = zero(UInt64)
    high = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            low = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 2
            high = PB.decode(d, UInt64, Val{:fixed})
        else
            Base.skip(d, wire_type)
        end
    end
    return UInt128Value(low, high)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UInt128Value)
    initpos = position(e.io)
    x.low != zero(UInt64) && PB.encode(e, 1, x.low, Val{:fixed})
    x.high != zero(UInt64) && PB.encode(e, 2, x.high, Val{:fixed})
    return position(e.io) - initpos
end
function PB._encoded_size(x::UInt128Value)
    encoded_size = 0
    x.low != zero(UInt64) && (encoded_size += PB._encoded_size(x.low, 1, Val{:fixed}))
    x.high != zero(UInt64) && (encoded_size += PB._encoded_size(x.high, 2, Val{:fixed}))
    return encoded_size
end

struct BooleanType end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BooleanType})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return BooleanType()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BooleanType)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BooleanType)
    encoded_size = 0
    return encoded_size
end

struct DecimalValue
    precision::Int32
    scale::Int32
    value::Union{Nothing,Int128Value}
end
DecimalValue(;precision = zero(Int32), scale = zero(Int32), value = nothing) = DecimalValue(precision, scale, value)
PB.default_values(::Type{DecimalValue}) = (;precision = zero(Int32), scale = zero(Int32), value = nothing)
PB.field_numbers(::Type{DecimalValue}) = (;precision = 1, scale = 2, value = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DecimalValue})
    precision = zero(Int32)
    scale = zero(Int32)
    value = Ref{Union{Nothing,Int128Value}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            precision = PB.decode(d, Int32)
        elseif field_number == 2
            scale = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, value)
        else
            Base.skip(d, wire_type)
        end
    end
    return DecimalValue(precision, scale, value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DecimalValue)
    initpos = position(e.io)
    x.precision != zero(Int32) && PB.encode(e, 1, x.precision)
    x.scale != zero(Int32) && PB.encode(e, 2, x.scale)
    !isnothing(x.value) && PB.encode(e, 3, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DecimalValue)
    encoded_size = 0
    x.precision != zero(Int32) && (encoded_size += PB._encoded_size(x.precision, 1))
    x.scale != zero(Int32) && (encoded_size += PB._encoded_size(x.scale, 2))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 3))
    return encoded_size
end

struct BeTreeLocator
    location::Union{Nothing,OneOf{<:Union{UInt128Value,Vector{UInt8}}}}
    element_count::Int64
    tree_height::Int64
end
BeTreeLocator(;location = nothing, element_count = zero(Int64), tree_height = zero(Int64)) = BeTreeLocator(location, element_count, tree_height)
PB.oneof_field_types(::Type{BeTreeLocator}) = (;
    location = (;root_pageid=UInt128Value, inline_data=Vector{UInt8}),
)
PB.default_values(::Type{BeTreeLocator}) = (;root_pageid = nothing, inline_data = UInt8[], element_count = zero(Int64), tree_height = zero(Int64))
PB.field_numbers(::Type{BeTreeLocator}) = (;root_pageid = 1, inline_data = 4, element_count = 2, tree_height = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BeTreeLocator})
    location = nothing
    element_count = zero(Int64)
    tree_height = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            location = OneOf(:root_pageid, PB.decode(d, Ref{UInt128Value}))
        elseif field_number == 4
            location = OneOf(:inline_data, PB.decode(d, Vector{UInt8}))
        elseif field_number == 2
            element_count = PB.decode(d, Int64)
        elseif field_number == 3
            tree_height = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return BeTreeLocator(location, element_count, tree_height)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BeTreeLocator)
    initpos = position(e.io)
    if isnothing(x.location);
    elseif x.location.name === :root_pageid
        PB.encode(e, 1, x.location[]::UInt128Value)
    elseif x.location.name === :inline_data
        PB.encode(e, 4, x.location[]::Vector{UInt8})
    end
    x.element_count != zero(Int64) && PB.encode(e, 2, x.element_count)
    x.tree_height != zero(Int64) && PB.encode(e, 3, x.tree_height)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BeTreeLocator)
    encoded_size = 0
    if isnothing(x.location);
    elseif x.location.name === :root_pageid
        encoded_size += PB._encoded_size(x.location[]::UInt128Value, 1)
    elseif x.location.name === :inline_data
        encoded_size += PB._encoded_size(x.location[]::Vector{UInt8}, 4)
    end
    x.element_count != zero(Int64) && (encoded_size += PB._encoded_size(x.element_count, 2))
    x.tree_height != zero(Int64) && (encoded_size += PB._encoded_size(x.tree_height, 3))
    return encoded_size
end

struct var"#Type"
    var"#type"::Union{Nothing,OneOf{<:Union{UnspecifiedType,StringType,IntType,FloatType,UInt128Type,Int128Type,DateType,DateTimeType,MissingType,DecimalType,BooleanType}}}
end
var"#Type"(;var"#type" = nothing) = var"#Type"(var"#type")
PB.oneof_field_types(::Type{var"#Type"}) = (;
    var"#type" = (;unspecified_type=UnspecifiedType, string_type=StringType, int_type=IntType, float_type=FloatType, uint128_type=UInt128Type, int128_type=Int128Type, date_type=DateType, datetime_type=DateTimeType, missing_type=MissingType, decimal_type=DecimalType, boolean_type=BooleanType),
)
PB.default_values(::Type{var"#Type"}) = (;unspecified_type = nothing, string_type = nothing, int_type = nothing, float_type = nothing, uint128_type = nothing, int128_type = nothing, date_type = nothing, datetime_type = nothing, missing_type = nothing, decimal_type = nothing, boolean_type = nothing)
PB.field_numbers(::Type{var"#Type"}) = (;unspecified_type = 1, string_type = 2, int_type = 3, float_type = 4, uint128_type = 5, int128_type = 6, date_type = 7, datetime_type = 8, missing_type = 9, decimal_type = 10, boolean_type = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"#Type"})
    var"#type" = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#type" = OneOf(:unspecified_type, PB.decode(d, Ref{UnspecifiedType}))
        elseif field_number == 2
            var"#type" = OneOf(:string_type, PB.decode(d, Ref{StringType}))
        elseif field_number == 3
            var"#type" = OneOf(:int_type, PB.decode(d, Ref{IntType}))
        elseif field_number == 4
            var"#type" = OneOf(:float_type, PB.decode(d, Ref{FloatType}))
        elseif field_number == 5
            var"#type" = OneOf(:uint128_type, PB.decode(d, Ref{UInt128Type}))
        elseif field_number == 6
            var"#type" = OneOf(:int128_type, PB.decode(d, Ref{Int128Type}))
        elseif field_number == 7
            var"#type" = OneOf(:date_type, PB.decode(d, Ref{DateType}))
        elseif field_number == 8
            var"#type" = OneOf(:datetime_type, PB.decode(d, Ref{DateTimeType}))
        elseif field_number == 9
            var"#type" = OneOf(:missing_type, PB.decode(d, Ref{MissingType}))
        elseif field_number == 10
            var"#type" = OneOf(:decimal_type, PB.decode(d, Ref{DecimalType}))
        elseif field_number == 11
            var"#type" = OneOf(:boolean_type, PB.decode(d, Ref{BooleanType}))
        else
            Base.skip(d, wire_type)
        end
    end
    return var"#Type"(var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"#Type")
    initpos = position(e.io)
    if isnothing(x.var"#type");
    elseif x.var"#type".name === :unspecified_type
        PB.encode(e, 1, x.var"#type"[]::UnspecifiedType)
    elseif x.var"#type".name === :string_type
        PB.encode(e, 2, x.var"#type"[]::StringType)
    elseif x.var"#type".name === :int_type
        PB.encode(e, 3, x.var"#type"[]::IntType)
    elseif x.var"#type".name === :float_type
        PB.encode(e, 4, x.var"#type"[]::FloatType)
    elseif x.var"#type".name === :uint128_type
        PB.encode(e, 5, x.var"#type"[]::UInt128Type)
    elseif x.var"#type".name === :int128_type
        PB.encode(e, 6, x.var"#type"[]::Int128Type)
    elseif x.var"#type".name === :date_type
        PB.encode(e, 7, x.var"#type"[]::DateType)
    elseif x.var"#type".name === :datetime_type
        PB.encode(e, 8, x.var"#type"[]::DateTimeType)
    elseif x.var"#type".name === :missing_type
        PB.encode(e, 9, x.var"#type"[]::MissingType)
    elseif x.var"#type".name === :decimal_type
        PB.encode(e, 10, x.var"#type"[]::DecimalType)
    elseif x.var"#type".name === :boolean_type
        PB.encode(e, 11, x.var"#type"[]::BooleanType)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"#Type")
    encoded_size = 0
    if isnothing(x.var"#type");
    elseif x.var"#type".name === :unspecified_type
        encoded_size += PB._encoded_size(x.var"#type"[]::UnspecifiedType, 1)
    elseif x.var"#type".name === :string_type
        encoded_size += PB._encoded_size(x.var"#type"[]::StringType, 2)
    elseif x.var"#type".name === :int_type
        encoded_size += PB._encoded_size(x.var"#type"[]::IntType, 3)
    elseif x.var"#type".name === :float_type
        encoded_size += PB._encoded_size(x.var"#type"[]::FloatType, 4)
    elseif x.var"#type".name === :uint128_type
        encoded_size += PB._encoded_size(x.var"#type"[]::UInt128Type, 5)
    elseif x.var"#type".name === :int128_type
        encoded_size += PB._encoded_size(x.var"#type"[]::Int128Type, 6)
    elseif x.var"#type".name === :date_type
        encoded_size += PB._encoded_size(x.var"#type"[]::DateType, 7)
    elseif x.var"#type".name === :datetime_type
        encoded_size += PB._encoded_size(x.var"#type"[]::DateTimeType, 8)
    elseif x.var"#type".name === :missing_type
        encoded_size += PB._encoded_size(x.var"#type"[]::MissingType, 9)
    elseif x.var"#type".name === :decimal_type
        encoded_size += PB._encoded_size(x.var"#type"[]::DecimalType, 10)
    elseif x.var"#type".name === :boolean_type
        encoded_size += PB._encoded_size(x.var"#type"[]::BooleanType, 11)
    end
    return encoded_size
end

struct Value
    value::Union{Nothing,OneOf{<:Union{String,Int64,Float64,UInt128Value,Int128Value,MissingValue,DateValue,DateTimeValue,DecimalValue,Bool}}}
end
Value(;value = nothing) = Value(value)
PB.oneof_field_types(::Type{Value}) = (;
    value = (;string_value=String, int_value=Int64, float_value=Float64, uint128_value=UInt128Value, int128_value=Int128Value, missing_value=MissingValue, date_value=DateValue, datetime_value=DateTimeValue, decimal_value=DecimalValue, boolean_value=Bool),
)
PB.default_values(::Type{Value}) = (;string_value = "", int_value = zero(Int64), float_value = zero(Float64), uint128_value = nothing, int128_value = nothing, missing_value = nothing, date_value = nothing, datetime_value = nothing, decimal_value = nothing, boolean_value = false)
PB.field_numbers(::Type{Value}) = (;string_value = 1, int_value = 2, float_value = 3, uint128_value = 4, int128_value = 5, missing_value = 6, date_value = 7, datetime_value = 8, decimal_value = 9, boolean_value = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Value})
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = OneOf(:string_value, PB.decode(d, String))
        elseif field_number == 2
            value = OneOf(:int_value, PB.decode(d, Int64))
        elseif field_number == 3
            value = OneOf(:float_value, PB.decode(d, Float64))
        elseif field_number == 4
            value = OneOf(:uint128_value, PB.decode(d, Ref{UInt128Value}))
        elseif field_number == 5
            value = OneOf(:int128_value, PB.decode(d, Ref{Int128Value}))
        elseif field_number == 6
            value = OneOf(:missing_value, PB.decode(d, Ref{MissingValue}))
        elseif field_number == 7
            value = OneOf(:date_value, PB.decode(d, Ref{DateValue}))
        elseif field_number == 8
            value = OneOf(:datetime_value, PB.decode(d, Ref{DateTimeValue}))
        elseif field_number == 9
            value = OneOf(:decimal_value, PB.decode(d, Ref{DecimalValue}))
        elseif field_number == 10
            value = OneOf(:boolean_value, PB.decode(d, Bool))
        else
            Base.skip(d, wire_type)
        end
    end
    return Value(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Value)
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :string_value
        PB.encode(e, 1, x.value[]::String)
    elseif x.value.name === :int_value
        PB.encode(e, 2, x.value[]::Int64)
    elseif x.value.name === :float_value
        PB.encode(e, 3, x.value[]::Float64)
    elseif x.value.name === :uint128_value
        PB.encode(e, 4, x.value[]::UInt128Value)
    elseif x.value.name === :int128_value
        PB.encode(e, 5, x.value[]::Int128Value)
    elseif x.value.name === :missing_value
        PB.encode(e, 6, x.value[]::MissingValue)
    elseif x.value.name === :date_value
        PB.encode(e, 7, x.value[]::DateValue)
    elseif x.value.name === :datetime_value
        PB.encode(e, 8, x.value[]::DateTimeValue)
    elseif x.value.name === :decimal_value
        PB.encode(e, 9, x.value[]::DecimalValue)
    elseif x.value.name === :boolean_value
        PB.encode(e, 10, x.value[]::Bool)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Value)
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :string_value
        encoded_size += PB._encoded_size(x.value[]::String, 1)
    elseif x.value.name === :int_value
        encoded_size += PB._encoded_size(x.value[]::Int64, 2)
    elseif x.value.name === :float_value
        encoded_size += PB._encoded_size(x.value[]::Float64, 3)
    elseif x.value.name === :uint128_value
        encoded_size += PB._encoded_size(x.value[]::UInt128Value, 4)
    elseif x.value.name === :int128_value
        encoded_size += PB._encoded_size(x.value[]::Int128Value, 5)
    elseif x.value.name === :missing_value
        encoded_size += PB._encoded_size(x.value[]::MissingValue, 6)
    elseif x.value.name === :date_value
        encoded_size += PB._encoded_size(x.value[]::DateValue, 7)
    elseif x.value.name === :datetime_value
        encoded_size += PB._encoded_size(x.value[]::DateTimeValue, 8)
    elseif x.value.name === :decimal_value
        encoded_size += PB._encoded_size(x.value[]::DecimalValue, 9)
    elseif x.value.name === :boolean_value
        encoded_size += PB._encoded_size(x.value[]::Bool, 10)
    end
    return encoded_size
end

struct RelEDB
    target_id::Union{Nothing,RelationId}
    path::Vector{String}
    types::Vector{var"#Type"}
end
RelEDB(;target_id = nothing, path = Vector{String}(), types = Vector{var"#Type"}()) = RelEDB(target_id, path, types)
PB.default_values(::Type{RelEDB}) = (;target_id = nothing, path = Vector{String}(), types = Vector{var"#Type"}())
PB.field_numbers(::Type{RelEDB}) = (;target_id = 1, path = 2, types = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelEDB})
    target_id = Ref{Union{Nothing,RelationId}}(nothing)
    path = PB.BufferedVector{String}()
    types = PB.BufferedVector{var"#Type"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, target_id)
        elseif field_number == 2
            PB.decode!(d, path)
        elseif field_number == 3
            PB.decode!(d, types)
        else
            Base.skip(d, wire_type)
        end
    end
    return RelEDB(target_id[], path[], types[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelEDB)
    initpos = position(e.io)
    !isnothing(x.target_id) && PB.encode(e, 1, x.target_id)
    !isempty(x.path) && PB.encode(e, 2, x.path)
    !isempty(x.types) && PB.encode(e, 3, x.types)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelEDB)
    encoded_size = 0
    !isnothing(x.target_id) && (encoded_size += PB._encoded_size(x.target_id, 1))
    !isempty(x.path) && (encoded_size += PB._encoded_size(x.path, 2))
    !isempty(x.types) && (encoded_size += PB._encoded_size(x.types, 3))
    return encoded_size
end

struct MinMonoid
    var"#type"::Union{Nothing,var"#Type"}
end
MinMonoid(;var"#type" = nothing) = MinMonoid(var"#type")
PB.default_values(::Type{MinMonoid}) = (;var"#type" = nothing)
PB.field_numbers(::Type{MinMonoid}) = (;var"#type" = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MinMonoid})
    var"#type" = Ref{Union{Nothing,var"#Type"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#type")
        else
            Base.skip(d, wire_type)
        end
    end
    return MinMonoid(var"#type"[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MinMonoid)
    initpos = position(e.io)
    !isnothing(x.var"#type") && PB.encode(e, 1, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::MinMonoid)
    encoded_size = 0
    !isnothing(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 1))
    return encoded_size
end

struct SumMonoid
    var"#type"::Union{Nothing,var"#Type"}
end
SumMonoid(;var"#type" = nothing) = SumMonoid(var"#type")
PB.default_values(::Type{SumMonoid}) = (;var"#type" = nothing)
PB.field_numbers(::Type{SumMonoid}) = (;var"#type" = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SumMonoid})
    var"#type" = Ref{Union{Nothing,var"#Type"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#type")
        else
            Base.skip(d, wire_type)
        end
    end
    return SumMonoid(var"#type"[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SumMonoid)
    initpos = position(e.io)
    !isnothing(x.var"#type") && PB.encode(e, 1, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::SumMonoid)
    encoded_size = 0
    !isnothing(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 1))
    return encoded_size
end

struct MaxMonoid
    var"#type"::Union{Nothing,var"#Type"}
end
MaxMonoid(;var"#type" = nothing) = MaxMonoid(var"#type")
PB.default_values(::Type{MaxMonoid}) = (;var"#type" = nothing)
PB.field_numbers(::Type{MaxMonoid}) = (;var"#type" = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MaxMonoid})
    var"#type" = Ref{Union{Nothing,var"#Type"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#type")
        else
            Base.skip(d, wire_type)
        end
    end
    return MaxMonoid(var"#type"[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MaxMonoid)
    initpos = position(e.io)
    !isnothing(x.var"#type") && PB.encode(e, 1, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::MaxMonoid)
    encoded_size = 0
    !isnothing(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 1))
    return encoded_size
end

struct BeTreeInfo
    key_types::Vector{var"#Type"}
    value_types::Vector{var"#Type"}
    storage_config::Union{Nothing,BeTreeConfig}
    relation_locator::Union{Nothing,BeTreeLocator}
end
BeTreeInfo(;key_types = Vector{var"#Type"}(), value_types = Vector{var"#Type"}(), storage_config = nothing, relation_locator = nothing) = BeTreeInfo(key_types, value_types, storage_config, relation_locator)
PB.reserved_fields(::Type{BeTreeInfo}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[3])
PB.default_values(::Type{BeTreeInfo}) = (;key_types = Vector{var"#Type"}(), value_types = Vector{var"#Type"}(), storage_config = nothing, relation_locator = nothing)
PB.field_numbers(::Type{BeTreeInfo}) = (;key_types = 1, value_types = 2, storage_config = 4, relation_locator = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BeTreeInfo})
    key_types = PB.BufferedVector{var"#Type"}()
    value_types = PB.BufferedVector{var"#Type"}()
    storage_config = Ref{Union{Nothing,BeTreeConfig}}(nothing)
    relation_locator = Ref{Union{Nothing,BeTreeLocator}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, key_types)
        elseif field_number == 2
            PB.decode!(d, value_types)
        elseif field_number == 4
            PB.decode!(d, storage_config)
        elseif field_number == 5
            PB.decode!(d, relation_locator)
        else
            Base.skip(d, wire_type)
        end
    end
    return BeTreeInfo(key_types[], value_types[], storage_config[], relation_locator[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BeTreeInfo)
    initpos = position(e.io)
    !isempty(x.key_types) && PB.encode(e, 1, x.key_types)
    !isempty(x.value_types) && PB.encode(e, 2, x.value_types)
    !isnothing(x.storage_config) && PB.encode(e, 4, x.storage_config)
    !isnothing(x.relation_locator) && PB.encode(e, 5, x.relation_locator)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BeTreeInfo)
    encoded_size = 0
    !isempty(x.key_types) && (encoded_size += PB._encoded_size(x.key_types, 1))
    !isempty(x.value_types) && (encoded_size += PB._encoded_size(x.value_types, 2))
    !isnothing(x.storage_config) && (encoded_size += PB._encoded_size(x.storage_config, 4))
    !isnothing(x.relation_locator) && (encoded_size += PB._encoded_size(x.relation_locator, 5))
    return encoded_size
end

struct Binding
    var::Union{Nothing,Var}
    var"#type"::Union{Nothing,var"#Type"}
end
Binding(;var = nothing, var"#type" = nothing) = Binding(var, var"#type")
PB.default_values(::Type{Binding}) = (;var = nothing, var"#type" = nothing)
PB.field_numbers(::Type{Binding}) = (;var = 1, var"#type" = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Binding})
    var = Ref{Union{Nothing,Var}}(nothing)
    var"#type" = Ref{Union{Nothing,var"#Type"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var)
        elseif field_number == 2
            PB.decode!(d, var"#type")
        else
            Base.skip(d, wire_type)
        end
    end
    return Binding(var[], var"#type"[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Binding)
    initpos = position(e.io)
    !isnothing(x.var) && PB.encode(e, 1, x.var)
    !isnothing(x.var"#type") && PB.encode(e, 2, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::Binding)
    encoded_size = 0
    !isnothing(x.var) && (encoded_size += PB._encoded_size(x.var, 1))
    !isnothing(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 2))
    return encoded_size
end

struct CSVColumn
    column_name::String
    target_id::Union{Nothing,RelationId}
    types::Vector{var"#Type"}
end
CSVColumn(;column_name = "", target_id = nothing, types = Vector{var"#Type"}()) = CSVColumn(column_name, target_id, types)
PB.default_values(::Type{CSVColumn}) = (;column_name = "", target_id = nothing, types = Vector{var"#Type"}())
PB.field_numbers(::Type{CSVColumn}) = (;column_name = 1, target_id = 2, types = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CSVColumn})
    column_name = ""
    target_id = Ref{Union{Nothing,RelationId}}(nothing)
    types = PB.BufferedVector{var"#Type"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            column_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, target_id)
        elseif field_number == 3
            PB.decode!(d, types)
        else
            Base.skip(d, wire_type)
        end
    end
    return CSVColumn(column_name, target_id[], types[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CSVColumn)
    initpos = position(e.io)
    !isempty(x.column_name) && PB.encode(e, 1, x.column_name)
    !isnothing(x.target_id) && PB.encode(e, 2, x.target_id)
    !isempty(x.types) && PB.encode(e, 3, x.types)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CSVColumn)
    encoded_size = 0
    !isempty(x.column_name) && (encoded_size += PB._encoded_size(x.column_name, 1))
    !isnothing(x.target_id) && (encoded_size += PB._encoded_size(x.target_id, 2))
    !isempty(x.types) && (encoded_size += PB._encoded_size(x.types, 3))
    return encoded_size
end

struct Attribute
    name::String
    args::Vector{Value}
end
Attribute(;name = "", args = Vector{Value}()) = Attribute(name, args)
PB.default_values(::Type{Attribute}) = (;name = "", args = Vector{Value}())
PB.field_numbers(::Type{Attribute}) = (;name = 1, args = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Attribute})
    name = ""
    args = PB.BufferedVector{Value}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        else
            Base.skip(d, wire_type)
        end
    end
    return Attribute(name, args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Attribute)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Attribute)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    return encoded_size
end

struct Term
    term_type::Union{Nothing,OneOf{<:Union{Var,Value}}}
end
Term(;term_type = nothing) = Term(term_type)
PB.oneof_field_types(::Type{Term}) = (;
    term_type = (;var=Var, constant=Value),
)
PB.default_values(::Type{Term}) = (;var = nothing, constant = nothing)
PB.field_numbers(::Type{Term}) = (;var = 1, constant = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Term})
    term_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            term_type = OneOf(:var, PB.decode(d, Ref{Var}))
        elseif field_number == 2
            term_type = OneOf(:constant, PB.decode(d, Ref{Value}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Term(term_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Term)
    initpos = position(e.io)
    if isnothing(x.term_type);
    elseif x.term_type.name === :var
        PB.encode(e, 1, x.term_type[]::Var)
    elseif x.term_type.name === :constant
        PB.encode(e, 2, x.term_type[]::Value)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Term)
    encoded_size = 0
    if isnothing(x.term_type);
    elseif x.term_type.name === :var
        encoded_size += PB._encoded_size(x.term_type[]::Var, 1)
    elseif x.term_type.name === :constant
        encoded_size += PB._encoded_size(x.term_type[]::Value, 2)
    end
    return encoded_size
end

struct Monoid
    value::Union{Nothing,OneOf{<:Union{OrMonoid,MinMonoid,MaxMonoid,SumMonoid}}}
end
Monoid(;value = nothing) = Monoid(value)
PB.oneof_field_types(::Type{Monoid}) = (;
    value = (;or_monoid=OrMonoid, min_monoid=MinMonoid, max_monoid=MaxMonoid, sum_monoid=SumMonoid),
)
PB.default_values(::Type{Monoid}) = (;or_monoid = nothing, min_monoid = nothing, max_monoid = nothing, sum_monoid = nothing)
PB.field_numbers(::Type{Monoid}) = (;or_monoid = 1, min_monoid = 2, max_monoid = 3, sum_monoid = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Monoid})
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = OneOf(:or_monoid, PB.decode(d, Ref{OrMonoid}))
        elseif field_number == 2
            value = OneOf(:min_monoid, PB.decode(d, Ref{MinMonoid}))
        elseif field_number == 3
            value = OneOf(:max_monoid, PB.decode(d, Ref{MaxMonoid}))
        elseif field_number == 4
            value = OneOf(:sum_monoid, PB.decode(d, Ref{SumMonoid}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Monoid(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Monoid)
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :or_monoid
        PB.encode(e, 1, x.value[]::OrMonoid)
    elseif x.value.name === :min_monoid
        PB.encode(e, 2, x.value[]::MinMonoid)
    elseif x.value.name === :max_monoid
        PB.encode(e, 3, x.value[]::MaxMonoid)
    elseif x.value.name === :sum_monoid
        PB.encode(e, 4, x.value[]::SumMonoid)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Monoid)
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :or_monoid
        encoded_size += PB._encoded_size(x.value[]::OrMonoid, 1)
    elseif x.value.name === :min_monoid
        encoded_size += PB._encoded_size(x.value[]::MinMonoid, 2)
    elseif x.value.name === :max_monoid
        encoded_size += PB._encoded_size(x.value[]::MaxMonoid, 3)
    elseif x.value.name === :sum_monoid
        encoded_size += PB._encoded_size(x.value[]::SumMonoid, 4)
    end
    return encoded_size
end

struct BeTreeRelation
    name::Union{Nothing,RelationId}
    relation_info::Union{Nothing,BeTreeInfo}
end
BeTreeRelation(;name = nothing, relation_info = nothing) = BeTreeRelation(name, relation_info)
PB.default_values(::Type{BeTreeRelation}) = (;name = nothing, relation_info = nothing)
PB.field_numbers(::Type{BeTreeRelation}) = (;name = 1, relation_info = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BeTreeRelation})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    relation_info = Ref{Union{Nothing,BeTreeInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, relation_info)
        else
            Base.skip(d, wire_type)
        end
    end
    return BeTreeRelation(name[], relation_info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BeTreeRelation)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.relation_info) && PB.encode(e, 2, x.relation_info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BeTreeRelation)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.relation_info) && (encoded_size += PB._encoded_size(x.relation_info, 2))
    return encoded_size
end

struct CSVData
    locator::Union{Nothing,CSVLocator}
    config::Union{Nothing,CSVConfig}
    columns::Vector{CSVColumn}
    asof::String
end
CSVData(;locator = nothing, config = nothing, columns = Vector{CSVColumn}(), asof = "") = CSVData(locator, config, columns, asof)
PB.default_values(::Type{CSVData}) = (;locator = nothing, config = nothing, columns = Vector{CSVColumn}(), asof = "")
PB.field_numbers(::Type{CSVData}) = (;locator = 1, config = 2, columns = 3, asof = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CSVData})
    locator = Ref{Union{Nothing,CSVLocator}}(nothing)
    config = Ref{Union{Nothing,CSVConfig}}(nothing)
    columns = PB.BufferedVector{CSVColumn}()
    asof = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, locator)
        elseif field_number == 2
            PB.decode!(d, config)
        elseif field_number == 3
            PB.decode!(d, columns)
        elseif field_number == 4
            asof = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return CSVData(locator[], config[], columns[], asof)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CSVData)
    initpos = position(e.io)
    !isnothing(x.locator) && PB.encode(e, 1, x.locator)
    !isnothing(x.config) && PB.encode(e, 2, x.config)
    !isempty(x.columns) && PB.encode(e, 3, x.columns)
    !isempty(x.asof) && PB.encode(e, 4, x.asof)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CSVData)
    encoded_size = 0
    !isnothing(x.locator) && (encoded_size += PB._encoded_size(x.locator, 1))
    !isnothing(x.config) && (encoded_size += PB._encoded_size(x.config, 2))
    !isempty(x.columns) && (encoded_size += PB._encoded_size(x.columns, 3))
    !isempty(x.asof) && (encoded_size += PB._encoded_size(x.asof, 4))
    return encoded_size
end

struct Cast
    input::Union{Nothing,Term}
    result::Union{Nothing,Term}
end
Cast(;input = nothing, result = nothing) = Cast(input, result)
PB.default_values(::Type{Cast}) = (;input = nothing, result = nothing)
PB.field_numbers(::Type{Cast}) = (;input = 2, result = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Cast})
    input = Ref{Union{Nothing,Term}}(nothing)
    result = Ref{Union{Nothing,Term}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            PB.decode!(d, input)
        elseif field_number == 3
            PB.decode!(d, result)
        else
            Base.skip(d, wire_type)
        end
    end
    return Cast(input[], result[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Cast)
    initpos = position(e.io)
    !isnothing(x.input) && PB.encode(e, 2, x.input)
    !isnothing(x.result) && PB.encode(e, 3, x.result)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Cast)
    encoded_size = 0
    !isnothing(x.input) && (encoded_size += PB._encoded_size(x.input, 2))
    !isnothing(x.result) && (encoded_size += PB._encoded_size(x.result, 3))
    return encoded_size
end

struct Pragma
    name::String
    terms::Vector{Term}
end
Pragma(;name = "", terms = Vector{Term}()) = Pragma(name, terms)
PB.default_values(::Type{Pragma}) = (;name = "", terms = Vector{Term}())
PB.field_numbers(::Type{Pragma}) = (;name = 1, terms = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Pragma})
    name = ""
    terms = PB.BufferedVector{Term}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return Pragma(name, terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Pragma)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.terms) && PB.encode(e, 2, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Pragma)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 2))
    return encoded_size
end

struct Atom
    name::Union{Nothing,RelationId}
    terms::Vector{Term}
end
Atom(;name = nothing, terms = Vector{Term}()) = Atom(name, terms)
PB.default_values(::Type{Atom}) = (;name = nothing, terms = Vector{Term}())
PB.field_numbers(::Type{Atom}) = (;name = 1, terms = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Atom})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    terms = PB.BufferedVector{Term}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return Atom(name[], terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Atom)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.terms) && PB.encode(e, 2, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Atom)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 2))
    return encoded_size
end

struct RelTerm
    rel_term_type::Union{Nothing,OneOf{<:Union{Value,Term}}}
end
RelTerm(;rel_term_type = nothing) = RelTerm(rel_term_type)
PB.oneof_field_types(::Type{RelTerm}) = (;
    rel_term_type = (;specialized_value=Value, term=Term),
)
PB.default_values(::Type{RelTerm}) = (;specialized_value = nothing, term = nothing)
PB.field_numbers(::Type{RelTerm}) = (;specialized_value = 1, term = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelTerm})
    rel_term_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            rel_term_type = OneOf(:specialized_value, PB.decode(d, Ref{Value}))
        elseif field_number == 2
            rel_term_type = OneOf(:term, PB.decode(d, Ref{Term}))
        else
            Base.skip(d, wire_type)
        end
    end
    return RelTerm(rel_term_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelTerm)
    initpos = position(e.io)
    if isnothing(x.rel_term_type);
    elseif x.rel_term_type.name === :specialized_value
        PB.encode(e, 1, x.rel_term_type[]::Value)
    elseif x.rel_term_type.name === :term
        PB.encode(e, 2, x.rel_term_type[]::Term)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelTerm)
    encoded_size = 0
    if isnothing(x.rel_term_type);
    elseif x.rel_term_type.name === :specialized_value
        encoded_size += PB._encoded_size(x.rel_term_type[]::Value, 1)
    elseif x.rel_term_type.name === :term
        encoded_size += PB._encoded_size(x.rel_term_type[]::Term, 2)
    end
    return encoded_size
end

struct Data
    data_type::Union{Nothing,OneOf{<:Union{RelEDB,BeTreeRelation,CSVData}}}
end
Data(;data_type = nothing) = Data(data_type)
PB.oneof_field_types(::Type{Data}) = (;
    data_type = (;rel_edb=RelEDB, betree_relation=BeTreeRelation, csv_data=CSVData),
)
PB.default_values(::Type{Data}) = (;rel_edb = nothing, betree_relation = nothing, csv_data = nothing)
PB.field_numbers(::Type{Data}) = (;rel_edb = 1, betree_relation = 2, csv_data = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Data})
    data_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            data_type = OneOf(:rel_edb, PB.decode(d, Ref{RelEDB}))
        elseif field_number == 2
            data_type = OneOf(:betree_relation, PB.decode(d, Ref{BeTreeRelation}))
        elseif field_number == 3
            data_type = OneOf(:csv_data, PB.decode(d, Ref{CSVData}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Data(data_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Data)
    initpos = position(e.io)
    if isnothing(x.data_type);
    elseif x.data_type.name === :rel_edb
        PB.encode(e, 1, x.data_type[]::RelEDB)
    elseif x.data_type.name === :betree_relation
        PB.encode(e, 2, x.data_type[]::BeTreeRelation)
    elseif x.data_type.name === :csv_data
        PB.encode(e, 3, x.data_type[]::CSVData)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Data)
    encoded_size = 0
    if isnothing(x.data_type);
    elseif x.data_type.name === :rel_edb
        encoded_size += PB._encoded_size(x.data_type[]::RelEDB, 1)
    elseif x.data_type.name === :betree_relation
        encoded_size += PB._encoded_size(x.data_type[]::BeTreeRelation, 2)
    elseif x.data_type.name === :csv_data
        encoded_size += PB._encoded_size(x.data_type[]::CSVData, 3)
    end
    return encoded_size
end

struct Primitive
    name::String
    terms::Vector{RelTerm}
end
Primitive(;name = "", terms = Vector{RelTerm}()) = Primitive(name, terms)
PB.default_values(::Type{Primitive}) = (;name = "", terms = Vector{RelTerm}())
PB.field_numbers(::Type{Primitive}) = (;name = 1, terms = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Primitive})
    name = ""
    terms = PB.BufferedVector{RelTerm}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return Primitive(name, terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Primitive)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.terms) && PB.encode(e, 2, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Primitive)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 2))
    return encoded_size
end

struct RelAtom
    name::String
    terms::Vector{RelTerm}
end
RelAtom(;name = "", terms = Vector{RelTerm}()) = RelAtom(name, terms)
PB.default_values(::Type{RelAtom}) = (;name = "", terms = Vector{RelTerm}())
PB.field_numbers(::Type{RelAtom}) = (;name = 3, terms = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelAtom})
    name = ""
    terms = PB.BufferedVector{RelTerm}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return RelAtom(name, terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelAtom)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 3, x.name)
    !isempty(x.terms) && PB.encode(e, 2, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelAtom)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 3))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 2))
    return encoded_size
end

# Stub definitions for cyclic types
struct var"##Stub#Abstraction"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Abstraction"
    vars::Vector{Binding}
    value::Union{Nothing,T1}
end

struct var"##Stub#Algorithm"{T1<:var"##Abstract#Script"} <: var"##Abstract#Algorithm"
    var"#global"::Vector{RelationId}
    body::Union{Nothing,T1}
end

struct var"##Stub#Assign"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Assign"
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
end

struct var"##Stub#Break"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Break"
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
end

struct var"##Stub#Conjunction"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Conjunction"
    args::Vector{T1}
end

struct var"##Stub#Constraint"{T1<:var"##Abstract#FunctionalDependency"} <: var"##Abstract#Constraint"
    name::Union{Nothing,RelationId}
    constraint_type::Union{Nothing,OneOf{T1}}
end

struct var"##Stub#Def"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Def"
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
end

struct var"##Stub#Disjunction"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Disjunction"
    args::Vector{T1}
end

struct var"##Stub#Exists"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Exists"
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
end

struct var"##Stub#FFI"{T1<:var"##Abstract#Formula"} <: var"##Abstract#FFI"
    name::String
    args::Vector{var"##Stub#Abstraction"{T1}}
    terms::Vector{Term}
end

struct var"##Stub#FunctionalDependency"{T1<:var"##Abstract#Formula"} <: var"##Abstract#FunctionalDependency"
    guard::Union{Nothing,var"##Stub#Abstraction"{T1}}
    keys::Vector{Var}
    values::Vector{Var}
end

struct var"##Stub#MonoidDef"{T1<:var"##Abstract#Formula"} <: var"##Abstract#MonoidDef"
    monoid::Union{Nothing,Monoid}
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
    value_arity::Int64
end

struct var"##Stub#MonusDef"{T1<:var"##Abstract#Formula"} <: var"##Abstract#MonusDef"
    monoid::Union{Nothing,Monoid}
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
    value_arity::Int64
end

struct var"##Stub#Not"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Not"
    arg::Union{Nothing,T1}
end

struct var"##Stub#Reduce"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Reduce"
    op::Union{Nothing,var"##Stub#Abstraction"{T1}}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    terms::Vector{Term}
end

struct var"##Stub#Script"{T1<:var"##Abstract#Construct"} <: var"##Abstract#Script"
    constructs::Vector{T1}
end

struct var"##Stub#Upsert"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Upsert"
    name::Union{Nothing,RelationId}
    body::Union{Nothing,var"##Stub#Abstraction"{T1}}
    attrs::Vector{Attribute}
    value_arity::Int64
end

struct var"##Stub#Construct"{T1<:var"##Abstract#Loop",T2<:var"##Abstract#Instruction"} <: var"##Abstract#Construct"
    construct_type::Union{Nothing,OneOf{<:Union{T1,T2}}}
end

struct var"##Stub#Loop"{T1<:var"##Abstract#Instruction"} <: var"##Abstract#Loop"
    init::Vector{T1}
    body::Union{Nothing,var"##Stub#Script"{var"##Stub#Construct"{var"##Stub#Loop"{T1},T1}}}
end

struct var"##Stub#Declaration"{T1<:var"##Abstract#Formula",T2<:var"##Abstract#Instruction"} <: var"##Abstract#Declaration"
    declaration_type::Union{Nothing,OneOf{<:Union{var"##Stub#Def"{T1},var"##Stub#Algorithm"{var"##Stub#Script"{var"##Stub#Construct"{var"##Stub#Loop"{T2},T2}}},var"##Stub#Constraint"{var"##Stub#FunctionalDependency"{T1}},Data}}}
end

struct var"##Stub#Instruction"{T1<:var"##Abstract#Formula"} <: var"##Abstract#Instruction"
    instr_type::Union{Nothing,OneOf{<:Union{var"##Stub#Assign"{T1},var"##Stub#Upsert"{T1},var"##Stub#Break"{T1},var"##Stub#MonoidDef"{T1},var"##Stub#MonusDef"{T1}}}}
end

struct var"##Stub#Formula" <: var"##Abstract#Formula"
    formula_type::Union{Nothing,OneOf{<:Union{var"##Stub#Exists"{var"##Stub#Formula"},var"##Stub#Reduce"{var"##Stub#Formula"},var"##Stub#Conjunction"{var"##Stub#Formula"},var"##Stub#Disjunction"{var"##Stub#Formula"},var"##Stub#Not"{var"##Stub#Formula"},var"##Stub#FFI"{var"##Stub#Formula"},Atom,Pragma,Primitive,RelAtom,Cast}}}
end

const Abstraction = var"##Stub#Abstraction"{var"##Stub#Formula"}
Abstraction(;vars = Vector{Binding}(), value = nothing) = Abstraction(vars, value)
PB.default_values(::Type{Abstraction}) = (;vars = Vector{Binding}(), value = nothing)
PB.field_numbers(::Type{Abstraction}) = (;vars = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Abstraction})
    vars = PB.BufferedVector{Binding}()
    value = Ref{Union{Nothing,Formula}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, vars)
        elseif field_number == 2
            PB.decode!(d, value)
        else
            Base.skip(d, wire_type)
        end
    end
    return Abstraction(vars[], value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Abstraction)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isnothing(x.value) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Abstraction)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

const Algorithm = var"##Stub#Algorithm"{var"##Stub#Script"{var"##Stub#Construct"{var"##Stub#Loop"{var"##Stub#Instruction"{var"##Stub#Formula"}},var"##Stub#Instruction"{var"##Stub#Formula"}}}}
Algorithm(;var"#global" = Vector{RelationId}(), body = nothing) = Algorithm(var"#global", body)
PB.default_values(::Type{Algorithm}) = (;var"#global" = Vector{RelationId}(), body = nothing)
PB.field_numbers(::Type{Algorithm}) = (;var"#global" = 1, body = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Algorithm})
    var"#global" = PB.BufferedVector{RelationId}()
    body = Ref{Union{Nothing,Script}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#global")
        elseif field_number == 2
            PB.decode!(d, body)
        else
            Base.skip(d, wire_type)
        end
    end
    return Algorithm(var"#global"[], body[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Algorithm)
    initpos = position(e.io)
    !isempty(x.var"#global") && PB.encode(e, 1, x.var"#global")
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Algorithm)
    encoded_size = 0
    !isempty(x.var"#global") && (encoded_size += PB._encoded_size(x.var"#global", 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    return encoded_size
end

const Assign = var"##Stub#Assign"{var"##Stub#Formula"}
Assign(;name = nothing, body = nothing, attrs = Vector{Attribute}()) = Assign(name, body, attrs)
PB.default_values(::Type{Assign}) = (;name = nothing, body = nothing, attrs = Vector{Attribute}())
PB.field_numbers(::Type{Assign}) = (;name = 1, body = 2, attrs = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Assign})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, body)
        elseif field_number == 3
            PB.decode!(d, attrs)
        else
            Base.skip(d, wire_type)
        end
    end
    return Assign(name[], body[], attrs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Assign)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    !isempty(x.attrs) && PB.encode(e, 3, x.attrs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Assign)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 3))
    return encoded_size
end

const Break = var"##Stub#Break"{var"##Stub#Formula"}
Break(;name = nothing, body = nothing, attrs = Vector{Attribute}()) = Break(name, body, attrs)
PB.default_values(::Type{Break}) = (;name = nothing, body = nothing, attrs = Vector{Attribute}())
PB.field_numbers(::Type{Break}) = (;name = 1, body = 2, attrs = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Break})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, body)
        elseif field_number == 3
            PB.decode!(d, attrs)
        else
            Base.skip(d, wire_type)
        end
    end
    return Break(name[], body[], attrs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Break)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    !isempty(x.attrs) && PB.encode(e, 3, x.attrs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Break)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 3))
    return encoded_size
end

const Conjunction = var"##Stub#Conjunction"{var"##Stub#Formula"}
Conjunction(;args = Vector{Formula}()) = Conjunction(args)
PB.default_values(::Type{Conjunction}) = (;args = Vector{Formula}())
PB.field_numbers(::Type{Conjunction}) = (;args = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Conjunction})
    args = PB.BufferedVector{Formula}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, args)
        else
            Base.skip(d, wire_type)
        end
    end
    return Conjunction(args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Conjunction)
    initpos = position(e.io)
    !isempty(x.args) && PB.encode(e, 1, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Conjunction)
    encoded_size = 0
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 1))
    return encoded_size
end

const Constraint = var"##Stub#Constraint"{var"##Stub#FunctionalDependency"{var"##Stub#Formula"}}
Constraint(;name = nothing, constraint_type = nothing) = Constraint(name, constraint_type)
PB.oneof_field_types(::Type{Constraint}) = (;
    constraint_type = (;functional_dependency=FunctionalDependency),
)
PB.default_values(::Type{Constraint}) = (;name = nothing, functional_dependency = nothing)
PB.field_numbers(::Type{Constraint}) = (;name = 2, functional_dependency = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    constraint_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            PB.decode!(d, name)
        elseif field_number == 1
            constraint_type = OneOf(:functional_dependency, PB.decode(d, Ref{FunctionalDependency}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Constraint(name[], constraint_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 2, x.name)
    if isnothing(x.constraint_type);
    elseif x.constraint_type.name === :functional_dependency
        PB.encode(e, 1, x.constraint_type[]::FunctionalDependency)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    if isnothing(x.constraint_type);
    elseif x.constraint_type.name === :functional_dependency
        encoded_size += PB._encoded_size(x.constraint_type[]::FunctionalDependency, 1)
    end
    return encoded_size
end

const Def = var"##Stub#Def"{var"##Stub#Formula"}
Def(;name = nothing, body = nothing, attrs = Vector{Attribute}()) = Def(name, body, attrs)
PB.default_values(::Type{Def}) = (;name = nothing, body = nothing, attrs = Vector{Attribute}())
PB.field_numbers(::Type{Def}) = (;name = 1, body = 2, attrs = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Def})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, body)
        elseif field_number == 3
            PB.decode!(d, attrs)
        else
            Base.skip(d, wire_type)
        end
    end
    return Def(name[], body[], attrs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Def)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    !isempty(x.attrs) && PB.encode(e, 3, x.attrs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Def)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 3))
    return encoded_size
end

const Disjunction = var"##Stub#Disjunction"{var"##Stub#Formula"}
Disjunction(;args = Vector{Formula}()) = Disjunction(args)
PB.default_values(::Type{Disjunction}) = (;args = Vector{Formula}())
PB.field_numbers(::Type{Disjunction}) = (;args = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Disjunction})
    args = PB.BufferedVector{Formula}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, args)
        else
            Base.skip(d, wire_type)
        end
    end
    return Disjunction(args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Disjunction)
    initpos = position(e.io)
    !isempty(x.args) && PB.encode(e, 1, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Disjunction)
    encoded_size = 0
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 1))
    return encoded_size
end

const Exists = var"##Stub#Exists"{var"##Stub#Formula"}
Exists(;body = nothing) = Exists(body)
PB.default_values(::Type{Exists}) = (;body = nothing)
PB.field_numbers(::Type{Exists}) = (;body = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Exists})
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            PB.decode!(d, body)
        else
            Base.skip(d, wire_type)
        end
    end
    return Exists(body[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Exists)
    initpos = position(e.io)
    !isnothing(x.body) && PB.encode(e, 3, x.body)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Exists)
    encoded_size = 0
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 3))
    return encoded_size
end

const FFI = var"##Stub#FFI"{var"##Stub#Formula"}
FFI(;name = "", args = Vector{Abstraction}(), terms = Vector{Term}()) = FFI(name, args, terms)
PB.default_values(::Type{FFI}) = (;name = "", args = Vector{Abstraction}(), terms = Vector{Term}())
PB.field_numbers(::Type{FFI}) = (;name = 1, args = 2, terms = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FFI})
    name = ""
    args = PB.BufferedVector{Abstraction}()
    terms = PB.BufferedVector{Term}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 3
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return FFI(name, args[], terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FFI)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.args) && PB.encode(e, 2, x.args)
    !isempty(x.terms) && PB.encode(e, 3, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FFI)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 3))
    return encoded_size
end

const FunctionalDependency = var"##Stub#FunctionalDependency"{var"##Stub#Formula"}
FunctionalDependency(;guard = nothing, keys = Vector{Var}(), values = Vector{Var}()) = FunctionalDependency(guard, keys, values)
PB.default_values(::Type{FunctionalDependency}) = (;guard = nothing, keys = Vector{Var}(), values = Vector{Var}())
PB.field_numbers(::Type{FunctionalDependency}) = (;guard = 1, keys = 2, values = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FunctionalDependency})
    guard = Ref{Union{Nothing,Abstraction}}(nothing)
    keys = PB.BufferedVector{Var}()
    values = PB.BufferedVector{Var}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, guard)
        elseif field_number == 2
            PB.decode!(d, keys)
        elseif field_number == 3
            PB.decode!(d, values)
        else
            Base.skip(d, wire_type)
        end
    end
    return FunctionalDependency(guard[], keys[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FunctionalDependency)
    initpos = position(e.io)
    !isnothing(x.guard) && PB.encode(e, 1, x.guard)
    !isempty(x.keys) && PB.encode(e, 2, x.keys)
    !isempty(x.values) && PB.encode(e, 3, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FunctionalDependency)
    encoded_size = 0
    !isnothing(x.guard) && (encoded_size += PB._encoded_size(x.guard, 1))
    !isempty(x.keys) && (encoded_size += PB._encoded_size(x.keys, 2))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 3))
    return encoded_size
end

const MonoidDef = var"##Stub#MonoidDef"{var"##Stub#Formula"}
MonoidDef(;monoid = nothing, name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64)) = MonoidDef(monoid, name, body, attrs, value_arity)
PB.default_values(::Type{MonoidDef}) = (;monoid = nothing, name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64))
PB.field_numbers(::Type{MonoidDef}) = (;monoid = 1, name = 2, body = 3, attrs = 4, value_arity = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MonoidDef})
    monoid = Ref{Union{Nothing,Monoid}}(nothing)
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    value_arity = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, monoid)
        elseif field_number == 2
            PB.decode!(d, name)
        elseif field_number == 3
            PB.decode!(d, body)
        elseif field_number == 4
            PB.decode!(d, attrs)
        elseif field_number == 5
            value_arity = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return MonoidDef(monoid[], name[], body[], attrs[], value_arity)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MonoidDef)
    initpos = position(e.io)
    !isnothing(x.monoid) && PB.encode(e, 1, x.monoid)
    !isnothing(x.name) && PB.encode(e, 2, x.name)
    !isnothing(x.body) && PB.encode(e, 3, x.body)
    !isempty(x.attrs) && PB.encode(e, 4, x.attrs)
    x.value_arity != zero(Int64) && PB.encode(e, 5, x.value_arity)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MonoidDef)
    encoded_size = 0
    !isnothing(x.monoid) && (encoded_size += PB._encoded_size(x.monoid, 1))
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 3))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 4))
    x.value_arity != zero(Int64) && (encoded_size += PB._encoded_size(x.value_arity, 5))
    return encoded_size
end

const MonusDef = var"##Stub#MonusDef"{var"##Stub#Formula"}
MonusDef(;monoid = nothing, name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64)) = MonusDef(monoid, name, body, attrs, value_arity)
PB.default_values(::Type{MonusDef}) = (;monoid = nothing, name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64))
PB.field_numbers(::Type{MonusDef}) = (;monoid = 1, name = 2, body = 3, attrs = 4, value_arity = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MonusDef})
    monoid = Ref{Union{Nothing,Monoid}}(nothing)
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    value_arity = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, monoid)
        elseif field_number == 2
            PB.decode!(d, name)
        elseif field_number == 3
            PB.decode!(d, body)
        elseif field_number == 4
            PB.decode!(d, attrs)
        elseif field_number == 5
            value_arity = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return MonusDef(monoid[], name[], body[], attrs[], value_arity)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MonusDef)
    initpos = position(e.io)
    !isnothing(x.monoid) && PB.encode(e, 1, x.monoid)
    !isnothing(x.name) && PB.encode(e, 2, x.name)
    !isnothing(x.body) && PB.encode(e, 3, x.body)
    !isempty(x.attrs) && PB.encode(e, 4, x.attrs)
    x.value_arity != zero(Int64) && PB.encode(e, 5, x.value_arity)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MonusDef)
    encoded_size = 0
    !isnothing(x.monoid) && (encoded_size += PB._encoded_size(x.monoid, 1))
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 3))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 4))
    x.value_arity != zero(Int64) && (encoded_size += PB._encoded_size(x.value_arity, 5))
    return encoded_size
end

const Not = var"##Stub#Not"{var"##Stub#Formula"}
Not(;arg = nothing) = Not(arg)
PB.default_values(::Type{Not}) = (;arg = nothing)
PB.field_numbers(::Type{Not}) = (;arg = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Not})
    arg = Ref{Union{Nothing,Formula}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, arg)
        else
            Base.skip(d, wire_type)
        end
    end
    return Not(arg[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Not)
    initpos = position(e.io)
    !isnothing(x.arg) && PB.encode(e, 1, x.arg)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Not)
    encoded_size = 0
    !isnothing(x.arg) && (encoded_size += PB._encoded_size(x.arg, 1))
    return encoded_size
end

const Reduce = var"##Stub#Reduce"{var"##Stub#Formula"}
Reduce(;op = nothing, body = nothing, terms = Vector{Term}()) = Reduce(op, body, terms)
PB.default_values(::Type{Reduce}) = (;op = nothing, body = nothing, terms = Vector{Term}())
PB.field_numbers(::Type{Reduce}) = (;op = 1, body = 2, terms = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Reduce})
    op = Ref{Union{Nothing,Abstraction}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    terms = PB.BufferedVector{Term}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, op)
        elseif field_number == 2
            PB.decode!(d, body)
        elseif field_number == 3
            PB.decode!(d, terms)
        else
            Base.skip(d, wire_type)
        end
    end
    return Reduce(op[], body[], terms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Reduce)
    initpos = position(e.io)
    !isnothing(x.op) && PB.encode(e, 1, x.op)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    !isempty(x.terms) && PB.encode(e, 3, x.terms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Reduce)
    encoded_size = 0
    !isnothing(x.op) && (encoded_size += PB._encoded_size(x.op, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    !isempty(x.terms) && (encoded_size += PB._encoded_size(x.terms, 3))
    return encoded_size
end

const Script = var"##Stub#Script"{var"##Stub#Construct"{var"##Stub#Loop"{var"##Stub#Instruction"{var"##Stub#Formula"}},var"##Stub#Instruction"{var"##Stub#Formula"}}}
Script(;constructs = Vector{Construct}()) = Script(constructs)
PB.default_values(::Type{Script}) = (;constructs = Vector{Construct}())
PB.field_numbers(::Type{Script}) = (;constructs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Script})
    constructs = PB.BufferedVector{Construct}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, constructs)
        else
            Base.skip(d, wire_type)
        end
    end
    return Script(constructs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Script)
    initpos = position(e.io)
    !isempty(x.constructs) && PB.encode(e, 1, x.constructs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Script)
    encoded_size = 0
    !isempty(x.constructs) && (encoded_size += PB._encoded_size(x.constructs, 1))
    return encoded_size
end

const Upsert = var"##Stub#Upsert"{var"##Stub#Formula"}
Upsert(;name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64)) = Upsert(name, body, attrs, value_arity)
PB.default_values(::Type{Upsert}) = (;name = nothing, body = nothing, attrs = Vector{Attribute}(), value_arity = zero(Int64))
PB.field_numbers(::Type{Upsert}) = (;name = 1, body = 2, attrs = 3, value_arity = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Upsert})
    name = Ref{Union{Nothing,RelationId}}(nothing)
    body = Ref{Union{Nothing,Abstraction}}(nothing)
    attrs = PB.BufferedVector{Attribute}()
    value_arity = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, name)
        elseif field_number == 2
            PB.decode!(d, body)
        elseif field_number == 3
            PB.decode!(d, attrs)
        elseif field_number == 4
            value_arity = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return Upsert(name[], body[], attrs[], value_arity)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Upsert)
    initpos = position(e.io)
    !isnothing(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    !isempty(x.attrs) && PB.encode(e, 3, x.attrs)
    x.value_arity != zero(Int64) && PB.encode(e, 4, x.value_arity)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Upsert)
    encoded_size = 0
    !isnothing(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    !isempty(x.attrs) && (encoded_size += PB._encoded_size(x.attrs, 3))
    x.value_arity != zero(Int64) && (encoded_size += PB._encoded_size(x.value_arity, 4))
    return encoded_size
end

const Construct = var"##Stub#Construct"{var"##Stub#Loop"{var"##Stub#Instruction"{var"##Stub#Formula"}},var"##Stub#Instruction"{var"##Stub#Formula"}}
Construct(;construct_type = nothing) = Construct(construct_type)
PB.oneof_field_types(::Type{Construct}) = (;
    construct_type = (;loop=Loop, instruction=Instruction),
)
PB.default_values(::Type{Construct}) = (;loop = nothing, instruction = nothing)
PB.field_numbers(::Type{Construct}) = (;loop = 1, instruction = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Construct})
    construct_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            construct_type = OneOf(:loop, PB.decode(d, Ref{Loop}))
        elseif field_number == 2
            construct_type = OneOf(:instruction, PB.decode(d, Ref{Instruction}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Construct(construct_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Construct)
    initpos = position(e.io)
    if isnothing(x.construct_type);
    elseif x.construct_type.name === :loop
        PB.encode(e, 1, x.construct_type[]::Loop)
    elseif x.construct_type.name === :instruction
        PB.encode(e, 2, x.construct_type[]::Instruction)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Construct)
    encoded_size = 0
    if isnothing(x.construct_type);
    elseif x.construct_type.name === :loop
        encoded_size += PB._encoded_size(x.construct_type[]::Loop, 1)
    elseif x.construct_type.name === :instruction
        encoded_size += PB._encoded_size(x.construct_type[]::Instruction, 2)
    end
    return encoded_size
end

const Loop = var"##Stub#Loop"{var"##Stub#Instruction"{var"##Stub#Formula"}}
Loop(;init = Vector{Instruction}(), body = nothing) = Loop(init, body)
PB.default_values(::Type{Loop}) = (;init = Vector{Instruction}(), body = nothing)
PB.field_numbers(::Type{Loop}) = (;init = 1, body = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Loop})
    init = PB.BufferedVector{Instruction}()
    body = Ref{Union{Nothing,Script}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, init)
        elseif field_number == 2
            PB.decode!(d, body)
        else
            Base.skip(d, wire_type)
        end
    end
    return Loop(init[], body[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Loop)
    initpos = position(e.io)
    !isempty(x.init) && PB.encode(e, 1, x.init)
    !isnothing(x.body) && PB.encode(e, 2, x.body)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Loop)
    encoded_size = 0
    !isempty(x.init) && (encoded_size += PB._encoded_size(x.init, 1))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 2))
    return encoded_size
end

const Declaration = var"##Stub#Declaration"{var"##Stub#Formula",var"##Stub#Instruction"{var"##Stub#Formula"}}
Declaration(;declaration_type = nothing) = Declaration(declaration_type)
PB.oneof_field_types(::Type{Declaration}) = (;
    declaration_type = (;def=Def, algorithm=Algorithm, constraint=Constraint, data=Data),
)
PB.default_values(::Type{Declaration}) = (;def = nothing, algorithm = nothing, constraint = nothing, data = nothing)
PB.field_numbers(::Type{Declaration}) = (;def = 1, algorithm = 2, constraint = 3, data = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Declaration})
    declaration_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            declaration_type = OneOf(:def, PB.decode(d, Ref{Def}))
        elseif field_number == 2
            declaration_type = OneOf(:algorithm, PB.decode(d, Ref{Algorithm}))
        elseif field_number == 3
            declaration_type = OneOf(:constraint, PB.decode(d, Ref{Constraint}))
        elseif field_number == 4
            declaration_type = OneOf(:data, PB.decode(d, Ref{Data}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Declaration(declaration_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Declaration)
    initpos = position(e.io)
    if isnothing(x.declaration_type);
    elseif x.declaration_type.name === :def
        PB.encode(e, 1, x.declaration_type[]::Def)
    elseif x.declaration_type.name === :algorithm
        PB.encode(e, 2, x.declaration_type[]::Algorithm)
    elseif x.declaration_type.name === :constraint
        PB.encode(e, 3, x.declaration_type[]::Constraint)
    elseif x.declaration_type.name === :data
        PB.encode(e, 4, x.declaration_type[]::Data)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Declaration)
    encoded_size = 0
    if isnothing(x.declaration_type);
    elseif x.declaration_type.name === :def
        encoded_size += PB._encoded_size(x.declaration_type[]::Def, 1)
    elseif x.declaration_type.name === :algorithm
        encoded_size += PB._encoded_size(x.declaration_type[]::Algorithm, 2)
    elseif x.declaration_type.name === :constraint
        encoded_size += PB._encoded_size(x.declaration_type[]::Constraint, 3)
    elseif x.declaration_type.name === :data
        encoded_size += PB._encoded_size(x.declaration_type[]::Data, 4)
    end
    return encoded_size
end

const Instruction = var"##Stub#Instruction"{var"##Stub#Formula"}
Instruction(;instr_type = nothing) = Instruction(instr_type)
PB.reserved_fields(::Type{Instruction}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.oneof_field_types(::Type{Instruction}) = (;
    instr_type = (;assign=Assign, upsert=Upsert, var"#break"=Break, monoid_def=MonoidDef, monus_def=MonusDef),
)
PB.default_values(::Type{Instruction}) = (;assign = nothing, upsert = nothing, var"#break" = nothing, monoid_def = nothing, monus_def = nothing)
PB.field_numbers(::Type{Instruction}) = (;assign = 1, upsert = 2, var"#break" = 3, monoid_def = 5, monus_def = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Instruction})
    instr_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            instr_type = OneOf(:assign, PB.decode(d, Ref{Assign}))
        elseif field_number == 2
            instr_type = OneOf(:upsert, PB.decode(d, Ref{Upsert}))
        elseif field_number == 3
            instr_type = OneOf(:var"#break", PB.decode(d, Ref{Break}))
        elseif field_number == 5
            instr_type = OneOf(:monoid_def, PB.decode(d, Ref{MonoidDef}))
        elseif field_number == 6
            instr_type = OneOf(:monus_def, PB.decode(d, Ref{MonusDef}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Instruction(instr_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Instruction)
    initpos = position(e.io)
    if isnothing(x.instr_type);
    elseif x.instr_type.name === :assign
        PB.encode(e, 1, x.instr_type[]::Assign)
    elseif x.instr_type.name === :upsert
        PB.encode(e, 2, x.instr_type[]::Upsert)
    elseif x.instr_type.name === :var"#break"
        PB.encode(e, 3, x.instr_type[]::Break)
    elseif x.instr_type.name === :monoid_def
        PB.encode(e, 5, x.instr_type[]::MonoidDef)
    elseif x.instr_type.name === :monus_def
        PB.encode(e, 6, x.instr_type[]::MonusDef)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Instruction)
    encoded_size = 0
    if isnothing(x.instr_type);
    elseif x.instr_type.name === :assign
        encoded_size += PB._encoded_size(x.instr_type[]::Assign, 1)
    elseif x.instr_type.name === :upsert
        encoded_size += PB._encoded_size(x.instr_type[]::Upsert, 2)
    elseif x.instr_type.name === :var"#break"
        encoded_size += PB._encoded_size(x.instr_type[]::Break, 3)
    elseif x.instr_type.name === :monoid_def
        encoded_size += PB._encoded_size(x.instr_type[]::MonoidDef, 5)
    elseif x.instr_type.name === :monus_def
        encoded_size += PB._encoded_size(x.instr_type[]::MonusDef, 6)
    end
    return encoded_size
end

const Formula = var"##Stub#Formula"
Formula(;formula_type = nothing) = Formula(formula_type)
PB.oneof_field_types(::Type{Formula}) = (;
    formula_type = (;exists=Exists, reduce=Reduce, conjunction=Conjunction, disjunction=Disjunction, not=Not, ffi=FFI, atom=Atom, pragma=Pragma, primitive=Primitive, rel_atom=RelAtom, cast=Cast),
)
PB.default_values(::Type{Formula}) = (;exists = nothing, reduce = nothing, conjunction = nothing, disjunction = nothing, not = nothing, ffi = nothing, atom = nothing, pragma = nothing, primitive = nothing, rel_atom = nothing, cast = nothing)
PB.field_numbers(::Type{Formula}) = (;exists = 1, reduce = 2, conjunction = 3, disjunction = 4, not = 5, ffi = 6, atom = 7, pragma = 8, primitive = 9, rel_atom = 10, cast = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Formula})
    formula_type = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            formula_type = OneOf(:exists, PB.decode(d, Ref{Exists}))
        elseif field_number == 2
            formula_type = OneOf(:reduce, PB.decode(d, Ref{Reduce}))
        elseif field_number == 3
            formula_type = OneOf(:conjunction, PB.decode(d, Ref{Conjunction}))
        elseif field_number == 4
            formula_type = OneOf(:disjunction, PB.decode(d, Ref{Disjunction}))
        elseif field_number == 5
            formula_type = OneOf(:not, PB.decode(d, Ref{Not}))
        elseif field_number == 6
            formula_type = OneOf(:ffi, PB.decode(d, Ref{FFI}))
        elseif field_number == 7
            formula_type = OneOf(:atom, PB.decode(d, Ref{Atom}))
        elseif field_number == 8
            formula_type = OneOf(:pragma, PB.decode(d, Ref{Pragma}))
        elseif field_number == 9
            formula_type = OneOf(:primitive, PB.decode(d, Ref{Primitive}))
        elseif field_number == 10
            formula_type = OneOf(:rel_atom, PB.decode(d, Ref{RelAtom}))
        elseif field_number == 11
            formula_type = OneOf(:cast, PB.decode(d, Ref{Cast}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Formula(formula_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Formula)
    initpos = position(e.io)
    if isnothing(x.formula_type);
    elseif x.formula_type.name === :exists
        PB.encode(e, 1, x.formula_type[]::Exists)
    elseif x.formula_type.name === :reduce
        PB.encode(e, 2, x.formula_type[]::Reduce)
    elseif x.formula_type.name === :conjunction
        PB.encode(e, 3, x.formula_type[]::Conjunction)
    elseif x.formula_type.name === :disjunction
        PB.encode(e, 4, x.formula_type[]::Disjunction)
    elseif x.formula_type.name === :not
        PB.encode(e, 5, x.formula_type[]::Not)
    elseif x.formula_type.name === :ffi
        PB.encode(e, 6, x.formula_type[]::FFI)
    elseif x.formula_type.name === :atom
        PB.encode(e, 7, x.formula_type[]::Atom)
    elseif x.formula_type.name === :pragma
        PB.encode(e, 8, x.formula_type[]::Pragma)
    elseif x.formula_type.name === :primitive
        PB.encode(e, 9, x.formula_type[]::Primitive)
    elseif x.formula_type.name === :rel_atom
        PB.encode(e, 10, x.formula_type[]::RelAtom)
    elseif x.formula_type.name === :cast
        PB.encode(e, 11, x.formula_type[]::Cast)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Formula)
    encoded_size = 0
    if isnothing(x.formula_type);
    elseif x.formula_type.name === :exists
        encoded_size += PB._encoded_size(x.formula_type[]::Exists, 1)
    elseif x.formula_type.name === :reduce
        encoded_size += PB._encoded_size(x.formula_type[]::Reduce, 2)
    elseif x.formula_type.name === :conjunction
        encoded_size += PB._encoded_size(x.formula_type[]::Conjunction, 3)
    elseif x.formula_type.name === :disjunction
        encoded_size += PB._encoded_size(x.formula_type[]::Disjunction, 4)
    elseif x.formula_type.name === :not
        encoded_size += PB._encoded_size(x.formula_type[]::Not, 5)
    elseif x.formula_type.name === :ffi
        encoded_size += PB._encoded_size(x.formula_type[]::FFI, 6)
    elseif x.formula_type.name === :atom
        encoded_size += PB._encoded_size(x.formula_type[]::Atom, 7)
    elseif x.formula_type.name === :pragma
        encoded_size += PB._encoded_size(x.formula_type[]::Pragma, 8)
    elseif x.formula_type.name === :primitive
        encoded_size += PB._encoded_size(x.formula_type[]::Primitive, 9)
    elseif x.formula_type.name === :rel_atom
        encoded_size += PB._encoded_size(x.formula_type[]::RelAtom, 10)
    elseif x.formula_type.name === :cast
        encoded_size += PB._encoded_size(x.formula_type[]::Cast, 11)
    end
    return encoded_size
end
